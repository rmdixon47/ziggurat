
--# Globals 
-- intended for any global use by main and at least one other class
-- Globals


SMALL_SQUARESIZE=38
MEDIUM_SQUARESIZE=48
LARGE_SQUARESIZE=56
-- BOARD SIZE choices for settings
SMALL_GAMEBOARD_SIZE=1
MEDIUM_GAMEBOARD_SIZE=2
LARGE_GAMEBOARD_SIZE=3
CUSTOM_GAMEBOARD_SIZE=4
-- set in mainSetDefaults
-- gameBoardSize=-1

squareSize = MEDIUM_SQUARESIZE
squareOffset = squareSize - 1
boardDiam=13
boardPixelDiam = boardDiam*squareOffset
numSquares=boardDiam*boardDiam
delta = (boardDiam)*squareSize/2 
delta =math.floor(delta)
print("delta: " .. delta)

local temp=0
xStart = WIDTH/2 - delta
yStart = HEIGHT/2 - delta -20
numLevels = 7
bsTable = {}
theMoveTable  = {}
redoTable = {}
gcCounter=0
gcCounterLimit=6000
-- a square marked justcaptured needs to be cleared on the next move
-- justCapturedSquare = BoardSquare(1, 1, 1, 1)
-- you can only play at the lowet level with empty squares
currentPlayLevel = 1 -- adjusred in checkBoardState
previousPlayLevel = 1 -- used to determine if play level changed
topPlayLevel=7 -- folks, we have a winner
gameHasBeenRestored=false
gameIsBeingRestored=false


levelColorTextTable = {
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "indigo",
    "violet"
}
-- initialized in main
globalColorTable = {}

-- moveState is either WHITEMOVE or BLACKMOVE
-- black has first move
NOMOVE = 0
BLACKMOVE = 1
WHITEMOVE = 2
GAMEOVER = 3
moveState = BLACKMOVE
moveText = {
    "BLACK",
    "WHITE",
    "GAME OVER"
}

whitePlayableCount = 0
blackPlayableCount = 0

moveInitials = {
    "B",
    "W",
    "O"
}
-- turn number is applied to a combo of black move and white move
currentTurnNumber=1
-- initialized to move object
currentMove = nil
previousMove=nil




mainInfoMessage="Messages go here"
PLAYERVSWHITEAI = 1
PLAYERVSBLACKAI = 2
BLACKAIVSWHITEAI=3
PLAYERVSPLAYERMODE = 4
MANUALPLAYMODE = 5

pauseAIvsAI=false

manualOffset=5    -- offset the stone from finger for visibility



-- we will move to this eventually
PLAY_AI_BLACK = 1

-- set to default in mainSetDefaults
-- playerMode = PLAYERVSWHITEAI
playerModeTextTable = {
    " vs White AI",
    " vs Black AI",
    "Black AI vs White AI",
    "Player vs Player",
    "Manual Play"
}
COPYRIGHTSTR= "1984-1986, 2019-2020"
gameName="Ziqqurat"
gameVersion="0.8.16"
gameComments = "got menu and gameboard screens to work in portrait mode. Still a lot to do for popup dialos as well as ai vs ai and manual play"

-- set to Defaults in Main mainSetDefalts()
theDefaults = nil
-- blackPlayerName = ""
-- whitePlayerName = ""
-- boardChangedState is set to true if a touch, capture or advancadvae adds, removes or moves a stone
boardChangedState = false
chooseStoneAdvanceState=false
advanceStonesTable = {}
doAddToUndo=false
-- moveCount is altered in undo redo functions
moveCount=0
refreshBoard = true
boardCornerX=0
boardCornerY=0
justCapturedMoveState=NOMOVE

-- which screen to draw
MENU_SCREEN = 1
GAMEBOARD_SCREEN = 2
LOG_SCREEN = 3
MENU_SCREEN = 4
DIALOG_SCREEN = 5
SETTINGS_SCREEN = 6
screenState=GAMEBOARD_SCREEN

-- gameState used for new and resume buttons initially
GAMESTATE_BEGIN = 1 -- no gameboard created, at settings menu initially
GAMESTATE_NEW = 2. -- gameboard created, but no moves have been made
GAMESTATE_INPROGRESS = 3 -- G
GAMESTATE_WON = 4 -- game has 
gameState=GAMESTATE_BEGIN
--  do not allow a move if move is in progreess
moveIsInProgress=false


-- play speed
PLAYSPEED_FAST=1
PLAYSPEED_NORMAL=2
PLAYSPEED_SLOW=3
PLAYSPEED_TURGID=4


-- global functions





--# Main
-- Ziqqurat

-- increment the level's index each time we add a sqaure to the board
-- Nope see levelIndexTables at bottom of file
lv1Index = 0
lv2Index = 0
lv3Index = 0
lv4Index = 0
lv5Index = 0
lv6Index = 0
lv7Index = 0

drawInterruptus=false
skipInterruptus=0
outputClearCount=0
-- approx every 15 minutes
outputClearLimit= 9000
-- outputClearLimit=18000000

function setup()
    -- print("GamePrototype")
    print("main setup")
        collectgarbage()
        collectgarbage()
        collectgarbage()
    displayMode(FULLSCREEN_NO_BUTTONS)
    displayMode(FULLSCREEN)
    if false then
        displayMode(STANDARD)
        xStart = xStart - 69
        outputClearLimit= 900000;
        gcCounterLimit=600000
    end
    saveProjectInfo("Description", "Codea version of Ziqqurat")
    saveProjectInfo("Author", "Retired Guy Software")
    saveProjectInfo("Date", os.date())
    saveProjectInfo("Version", version)
    saveProjectInfo("Comments", gameComments)
    -- monitor frames per second
    -- additional code in draw
    
    FPS = 0
    parameter.watch("FPS")
    timeInterval = 0
    frameCount = 0
    -- mainSetDefaults()
    confirmLoseExistingOnCloseMP = MessagePanel("Existing Game will be lost on closing. Is this OK?")
    confirmLoseExistingOnCloseMP.action = function() oldClose() end
    oldClose = close -- Make a function that does the same thing as the originl close function
    close = function() -- Must be afte rsetting oldClose (not as a usual function declaration), otherwise oldClose won't work
        print("override of original closel")
        if onClose() then
            oldClose()
        end
    end
    loadingGameInProgressMP=MessagePanel("Loading game in progress...")
    loadingGameInProgressMP.msgType=MESSAGE_PANEL_FLOATING
    globalColorTable[1]=redColor
    globalColorTable[2] = orangeColor
    globalColorTable[3]  = yellowColor
    globalColorTable[4]  = greenColor
    globalColorTable[5]= royalblueColor
    globalColorTable[6]= indigoColor
    globalColorTable[7]= purpleColor
    globalColorTable[8] = whiteColor
    -- game name and version
    print(defaultInfoMessage)
    theGameBoard = nil -- we do this in initial menu
    
    screenState = MENU_SCREEN
    gameState = GAMESTATE_BEGIN

    theSettings = Settings()
    theMenuPanel = MenuPanel()

    -- theLogPanel = LogPanel()
    createAIPlayers()
    
    
    -- theAIPlayer= AIPlayer()
    mainInit()
    --[[
    playerModeInfo=playerModeTextTable[theSettings.playerMode]
    playSpeedText=theSettings.playSpeedDisplayTable[theSettings.playSpeed]
    defaultInfoMessage=gameName.." v "..gameVersion.."    "..playerModeInfo..". Play Speed: "..playSpeedText

      ]]
        -- make sure settings are loaded before calling loadcurrent
    loadCurrentGame()  
end

function createAIPlayers()
    theBlackAIPlayer=AIPlayer(BLACKMOVE)
    theWhiteAIPlayer=AIPlayer(WHITEMOVE)
    if isAIWhitePlayerMode() then
        theAIPlayer=theWhiteAIPlayer
    elseif isAIBlackPlayerMode() then
        theAIPlayer=theBlackAIPlayer
    else
        theAIPlayer= AIPlayer()
    end
    
end

-- This function gets called once every framegameProtype<<<n
function draw()
    -- This sets a dark background color 
    --  easyButton = Button("Easy", vec2(mLocX, mLocY), mButtonSize.x, mButtonSize.y)
    
    -- background(0,0,0,0)
    xStart = WIDTH/2 - delta
    yStart = HEIGHT/2 - delta -20
    background(darkslategrayColor)

    frameCount = frameCount + 1
    timeInterval = timeInterval + DeltaTime
    
    if timeInterval > 1 then
        FPS = math.round(frameCount / timeInterval)
        timeInterval = 0
        frameCount = 0
    end
    gcCounter = gcCounter + 1
    if gcCounter > gcCounterLimit then
        print("garbage collecting")
        print(gcCounter)
        gcCounter=0
        collectgarbage()
        collectgarbage()
        collectgarbage()    
    end  
    outputClearCount = outputClearCount + 1
    if outputClearCount > outputClearLimit then
        outputClearCount = 0
        output.clear()
    end
    if screenState == GAMEBOARD_SCREEN then
        theGameBoard:draw()
    --[[
    elseif screenState == LOG_SCREEN then
        theLogPanel:draw()     
          ]]
    elseif screenState == MENU_SCREEN then
        theMenuPanel:draw()   
    
    else
        alert("screen type not supported")
        theMenuPanel:draw()   
    end
    confirmLoseExistingOnCloseMP:draw()
    
    -- for  z = 1, 5000 do xyz = 1 end
end


function touched(touch)  
    if confirmLoseExistingOnCloseMP.active then
        confirmLoseExistingOnCloseMP:touched(touch)     
        return
    end
    if screenState == MENU_SCREEN then
        theMenuPanel:touched(touch)
        return
    end 
    
    theGameBoard:touched(touch)  
 end

function sizeChanged(newWidth, newHeight)
    -- alert("sizeChanged")
    print("sizeChanged")
    xStart = WIDTH/2 - delta
    yStart = HEIGHT/2 - delta -20
    if theGameBoard then
        theGameBoard:sizeChanged(newWidth, newHeight)
    end
        
end

-- we overrode close() to call this. 
function onClose()
    print("You can do something before we close")
    -- alert("override of original close")
    if gameState == GAMESTATE_INPROGRESS then
        if theSettings.saveRestoreCurrentGame then
            print("game in progrees, savegame true so saveit and close")
            -- alert("game in progrees, savegame true so saveit and close")
            saveCurrentGame()
            return true
        else
            print("game in progrees, confirm mp now active")
            confirmLoseExistingOnCloseMP.active=true
            return false
        end
     return false
    end
    return true
end

function saveCurrentGame()
    -- local saveGameTable = self:serializeMoveTable  
    if currentMove.bs == nil then
        print("saveCurrentGame:currentMove.bs nil, skipping addMove")
    else
        print("saveCurrentGame:currentMove.bs ok, adding to move table")
        addMoveToTheMoveTable() -- needed torestore
    end
    local gmSerlzr = GameSerializer()
    jstr = gmSerlzr:serializeCurrentGame()
    pasteboard.copy(jstr)
    -- local ext = self.saveGameDialog.gameExt
    local gameName = theSettings.currentGameKey
    saveLocalData(gameName,jstr)
    local s =string.format("Current game saved as \"%s\" at close.", gameName)
    -- alert(s)
end

-- load currentgame if it exists and setring is true
-- always nuke currentgame, dont want stale ones hanging around
function loadCurrentGame()
    print("loadCurrentGame")
    if theSettings.saveRestoreCurrentGame then
        local gameName = theSettings.currentGameKey
        local jsonStr = readLocalData(gameName)
        -- alert(jsonStr)
        if jsonStr then
            -- print(#jsonStr)
                print("loading saved currentGame")
                loadingGameInProgressMP.active=true
                RestoreGameDialog:restoreGame(gameName,jsonStr)
        end
    end
    -- nuke watever us tgere 
    print("nuke local data current game")
    saveLocalData(theSettings.currentGameKey,nil)
end

-- globals for ai modes
function isAIPlayerMode()
    return theSettings.playerMode == PLAYERVSWHITEAI 
        or theSettings.playerMode == PLAYERVSBLACKAI
end

function isAIWhitePlayerMode()
    return theSettings.playerMode == PLAYERVSWHITEAI
end

function isAIBlackPlayerMode()
    return theSettings.playerMode == PLAYERVSBLACKAI
end

function isAIvsAIPlayerMode()
    return theSettings.playerMode == BLACKAIVSWHITEAI
end

function isManualPlayMode()
    return theSettings.playerMode == MANUALPLAYMODE
end

function createDefaultInfoMessage()
    local pName = ""
    if isAIWhitePlayerMode() then
        pName = "Player(Black)"
    elseif isAIBlackPlayerMode() then
        pName = "Player(White)" 
    else
        pName=""
    end
    playerModeInfo=pName..playerModeTextTable[theSettings.playerMode]
    playSpeedText=theSettings.playSpeedDisplayTable[theSettings.playSpeed]
    defaultInfoMessage=gameName.." v "..gameVersion.."    "..playerModeInfo.." — Play Speed:"..playSpeedText
end

function mainInit()
    createDefaultInfoMessage()
    mainInfoMessage = defaultInfoMessage
    currentTurnNumber=1
    currentPlayLevel = 1 -- adjusred in checkBoardState
    previousPlayLevel = 1 --
    displayJustCapturedMsg=false
    currentPlayLevelChanged=false
    -- black has 1st move until we develop handicap
    moveState = BLACKMOVE
    currentMove = Move(currentTurnNumber, BLACKMOVE)
    theMoveTable  = {}
    redoTable = {}
    lv1Index = 0
    lv2Index = 0
    lv3Index = 0
    lv4Index = 0
    lv5Index = 0
    lv6Index = 0
    lv7Index = 0
    lv1Ctr=1
    lv2Ctr=1
    lv3Ctr=1
    lv4Ctr=1
    lv5Ctr=1
    lv6Ctr=1
end

function toggleMove()
    if isManualPlayMode() then
        return
    end
    if moveIsInProgress then
        return
    end
    

    moveIsInProgress=true
    local psTime = theSettings:getPlaySpeedTme()
    local theDelay = psTime + 0.5
    tween.delay( theDelay, function() moveIsInProgress=false end )
    print("toggleMove moveState"..moveState)
    if moveState == GAMEOVER then
        print("toggleMove - Game Over no more toggling!")
        return
    end

    gameHasBeenRestored=false
    if passedMoveFlag then
        if isAIvsAIPlayerMode() then
            passedMoveFlag=false
        elseif moveState == theAIPlayer.moveState then
            print("passed move flag true for ai guy")
        else
            print("passedMoveFlag true")
            passedMoveFlag=false
            local s = string.format("toggleMove- passed move for %s",moveText[moveState])
            passMoveFloatingMP.message=s
        end
    end
    if moveState == WHITEMOVE then
        moveState = BLACKMOVE
        clearJustCapturedWhiteFlags()
    elseif moveState == BLACKMOVE then
        moveState = WHITEMOVE
        clearJustCapturedBlackFlags()
    else
        movestate = BLACKMOVE
        clearJustCapturedWhiteFlags()
    end
    print("togglemove - changed moveState to "..moveState)
    if moveState == BLACKMOVE then
        currentTurnNumber = currentTurnNumber + 1
        print("togglemove - currentTurnNumber now: "..currentTurnNumber)
    end
    -- dumpMoves()
    updateCurrentMoveBSTable()
    -- start new move
    currentMove = Move(currentTurnNumber, moveState)
    -- print("new currentMove created:")
    -- print(currentMove)

    tween.delay(0.1, function() checkAIPlayerMove() end)


end

function checkAIPlayerMove()
    if pauseAIvsAI then
        tween.delay(1.0, function() checkAIPlayerMove() end)
        return
    end

    local aiMode=false
    if isAIvsAIPlayerMode() then
        mainInfoMessage = defaultInfoMessage
        aiMode=true
        if moveState==BLACKMOVE then
            theAIPlayer=theBlackAIPlayer
        elseif moveState == WHITEMOVE then
            theAIPlayer=theWhiteAIPlayer
        end
    elseif isAIPlayerMode() then
        aiMode=true      
    end
    
    if aiMode then
        
        if moveState == theAIPlayer.moveState then
            -- print("isAIPlayerMode true")
            if theGameBoard.triggerAIFirstMove then
                
                print("triggerAIFirstMove true")
                return
            end
            print("checkAIPayerMove:ready for theAIPlayer to move")
            -- clear flags
            
            checkCurrentPlayLevel()
            local psTime = theSettings:getPlaySpeedTme()
            tween.delay( psTime, function() makeAIMove() end )
            -- makeAIMove()
        end
    else
        
    end
end

function original_checkAIPlayerMove()
    if isAIPlayerMode()and moveState == theAIPlayer.moveState then
        -- print("isAIPlayerMode true")
        if theGameBoard.triggerAIFirstMove then

            print("triggerAIFirstMove true")
            return
        end
        print("checkAIPayerMove:ready for theAIPlayer to move")
        checkCurrentPlayLevel()
        local psTime = theSettings:getPlaySpeedTme()
        tween.delay( psTime, function() makeAIMove() end )
        -- makeAIMove()
    else

    end
end

function makeAIMove()
    -- clearAiStoneFlags()
    clearChoiceStoneFlags()
    clearJustMovedFlags()
    clearAdvanceStoneFlags()
    clearJustCapturedByAIFlags()
    if passedMoveFlag and
    moveState == theAIPlayer.moveState then
        print("passed move flag true for ai guy, no ai move")
            moveIsInProgress=false
        toggleMove()
        return
    end
    theAIPlayer:move()
    moveIsInProgress=false
    if chooseStoneAdvanceState then
        -- notoggll
        theAIPlayer:move()
    else
        toggleMove()
    end
    checkStateOfTheBoard()   
end

function resetBsTable()
   -- When starting a new game this function will
   -- reset the table
    for i=1, numSquares do 
        bsTable[i] = nil
    end
    bsTable = {}

end


function initializeTheMoveTable()
    local moveStateTable = {}
    for i=1, numSquares do 
       moveStateTable[i] = EMPTYSTONESTATE
    end
    table.insert( theMoveTable, 1, moveStateTable)
end

-- we add a table of current set of stone tables
-- a move also clears the redoTable
function addMoveToTheMoveTable()
    -- moveCount = moveCount + 1
    -- print("addMoveTotheMoveTable. moveCount: "..moveCount)
    -- reset redo table 
    
    redoTable = {}
    doAddToUndo=false
    updateCurrentMoveBSTable()
    table.insert( theMoveTable, 1, currentMove)
    previousMove=currentMove
    
end

function updateCurrentMoveBSTable()
    local moveStateTable = {}
    for i=1, numSquares do 
       moveStateTable[i] = bsTable[i].stoneState
    end
    currentMove.boardStateTable  = moveStateTable
    currentMove.blackStonesCaptured = theGameBoard.blackStonesCaptured
    currentMove.whiteStonesCaptured = theGameBoard.whiteStonesCaptured
end


function undoMove()
    -- print("undoMove")
    if next(theMoveTable) == nil then
   -- theMoveTable is empty
        print("theMoveTable empty")
        mainInfoMessage="No more moves to undo"
        return
    end
    
    
    -- print("undoMove. moveCount: "..moveCount)
    ::zrestartloop::
    addMoveToRedoTable()
    local moveObject = table.remove(theMoveTable, 1)

    str="false"
    if moveObject.pass then
        str="true"
    end
    print("undoMove - moveObject.pass:"..str)

    
    if moveObject.pass then
        currentMove = Move(currentTurnNumber, moveObject.moveType)
        currentMove.bs=moveObject.bs
        currentMove.pass = moveObject.pass
        currentTurnNumber=moveObject.turnNumber
        -- skip passes
        goto zrestartloop
        -- moveObject = table.remove(theMoveTable, 1)
    end

    
    for i=1, numSquares do 
        bsTable[i].stoneState = moveObject.boardStateTable[i] 
    end
    currentTurnNumber = moveObject.turnNumber
    -- eventually we may want to track the move state in an undo structure
    -- as of 08.01.2019 we only store stone states for undo
    moveState = moveObject.moveType
    theGameBoard.blackStonesCaptured = moveObject.blackStonesCaptured
    theGameBoard.whiteStonesCaptured = moveObject.whiteStonesCaptured
    
    currentMove = Move(currentTurnNumber, moveState)
    currentMove.bs=moveObject.bs
    currentMove.pass = moveObject.pass
    checkCurrentPlayLevelAfterUndo()
    
end
    
    
function redoMove()
    -- print("undoMove")
    if next(redoTable) == nil then
   -- redoTable is empty
        -- print("redoTable empty")
        mainInfoMessage="No more moves to redo"
        return
    end
    -- redo is like a move, so add cuurent state to theMoveTable
    local moveStateTable = {}
    for i=1, numSquares do 
       moveStateTable[i] = bsTable[i].stoneState
    end
    currentMove.boardStateTable = moveStateTable
    table.insert( theMoveTable, 1, currentMove)
    -- now updtae the move &  board from the redo table
    local moveObject = table.remove(redoTable, 1)
    updateBoardFromMoveObject(moveObject)
    checkCurrentPlayLevel()
    
end


function updateBoardFromMoveObject(moveObject)
    moveStateTable = moveObject.boardStateTable
    for i=1, numSquares do
        local state = moveStateTable[i]
        if state == EMPTYSTONESTATE then
            nada=true
        else
            -- print("update:movetable at i = "..i.." has non empty state: "..state)
        end
        bsTable[i].stoneState = moveStateTable[i]
    end 
    currentTurnNumber = moveObject.turnNumber
    if moveObject.moveType==BLACKMOVE then
        moveState=WHITEMOVE
    elseif moveObject.moveType== WHITEMOVE then
        moveState=BLACKMOVE
        currentTurnNumber = currentTurnNumber + 1
    end

    currentMove = Move(currentTurnNumber, moveState)
    --[[
    currentTurnNumber = moveObject.turnNumber
    moveState = moveObject.moveType
    bs = moveObject.bs
    currentMove = Move(currentTurnNumber, moveState)
    currentMove.bs=bs
    currentMove.pass = moveObject.pass
      ]]
end


function addMoveToRedoTable()
    -- capture current state before you do undo
    local moveStateTable = {}
    for i=1, numSquares do 
       moveStateTable[i] = bsTable[i].stoneState
    end
    currentMove.boardStateTable = moveStateTable
    currentMove.turnNumber = currentTurnNumber
    table.insert(redoTable, 1, currentMove)
    
end


function checkCurrentPlayLevelAfterUndo()
    if currentPlayLevel == 1 then
        return  -- undo wont go lower      
    end
    for i=1, numSquares do
        bs = bsTable[i]
        if bs.stoneState == EMPTYSTONESTATE and bs.level < currentPlayLevel then
            currentPlayLevel = bs.level
            currentPlayLevelChanged=true
            clearJustCapturedBlackFlags()
            clearJustCapturedWhiteFlags()
            clearStoneChooseFlags()
            mainInfoMessage = "Current Play Level is now "
                ..currentPlayLevel.." ("..levelColorTextTable[currentPlayLevel]..")"      
            
            goto zbreak
        end
    end -- end for
    currentPlayLevelChanged=false
    ::zbreak::
end

function checkCurrentPlayLevel() 
    if chooseStoneAdvanceState then
        print("chooseStoneAdvance true at checkCurrentPlayLevel")
        print("skip check")
        return
    else
        -- print("chooseStoneAdvance false at checkCurrentPlayLaevel")
    end    
    previousPlayLevel = currentPlayLevel
    print("previousPlayLevel:"..previousPlayLevel)
    currentPlayLevel = numLevels
    local aSquareIsAdvancing=false
    for i=1, numSquares do
        bs = bsTable[i]
        if bs.advanceStoneFlag then
            aSquareIsAdvancing=true
        end
        if bs.stoneState == EMPTYSTONESTATE and bs.level <= currentPlayLevel then
            currentPlayLevel = bs.level
        end     
    end 

    if currentPlayLevel > previousPlayLevel then
        -- make sure we srart fresh on the new level
        -- alert("moving to next play level")
        -- print("set currentPlayLevelChanged to true")
        currentPlayLevelChanged=true
        clearJustCapturedBlackFlags()
        clearJustCapturedWhiteFlags()
        clearStoneChooseFlags()
        local s=string.format("moving to next play level - movestate:%s  currentMove.moveType: %s  playerMode: %s",
        moveText[moveState], moveText[currentMove.moveType], playerModeTextTable[theSettings.playerMode])
        -- alert(s)
        print(s)
        -- toggleMove()

        if gameHasBeenRestored then
            gameHasBeenRestored=false
        else
            mainInfoMessage = "Current Play Level is now "
            ..currentPlayLevel.." ("..levelColorTextTable[currentPlayLevel]..")"
            if currentPlayLevel == 7 then
                -- dont show alert, bad things happen
                return
            end
            if isAIvsAIPlayerMode() then
                print("AIvsAI - not displaying level change alert")
            else
                print("settin playlevel change alert active")
                theGameBoard.playLevelChangedMP.message=mainInfoMessage
                theGameBoard.playLevelChangedMP.active=true
            end
        end
        
        
    else
        -- print("set currentPlayLevelChanged to false")
        currentPlayLevelChanged=false
    end
end

--each level table get a counter
--  lua arrays vstart at 1
lv1Ctr=1
lv2Ctr=1
lv3Ctr=1
lv4Ctr=1
lv5Ctr=1
lv6Ctr=1

function resetLevelIndexes()
    lv1Ctr=1
    lv2Ctr=1
    lv3Ctr=1
    lv4Ctr=1
    lv5Ctr=1
    lv6Ctr=1
end
function getNextLevelIndex(level)
    -- we make the drd row by row, but indexes are incremented per level starting 
    -- ar lower right corner counter clockwise
    -- the level tables take into account the order that the grid is created    
    if level == 1 then
        idx = lv1Table[lv1Ctr]
        lv1Ctr = lv1Ctr + 1
        -- print("return level 1  idx:"..idx)
        return idx
    elseif level == 2 then
        idx = lv2Table[lv2Ctr]
        lv2Ctr = lv2Ctr + 1
        -- print("return level 2 idx:"..idx)
        return idx
    elseif level == 3 then
        idx = lv3Table[lv3Ctr]
        lv3Ctr = lv3Ctr + 1
        -- print("return level 3 idx:"..idx)
        return idx
    elseif level == 4 then
        idx = lv4Table[lv4Ctr]
        lv4Ctr = lv4Ctr + 1
        -- print("return level 4 idx:"..idx)
        return idx
    elseif level == 5 then
        idx = lv5Table[lv5Ctr]
        lv5Ctr = lv5Ctr + 1
        -- print("return level 5 idx:"..idx)
        return idx 
    elseif level == 6 then
        idx = lv6Table[lv6Ctr]
        lv6Ctr = lv6Ctr + 1
        -- print("return level 6 idx:"..idx)
        return idx
    else
        --  level 7 has one index
        return 1
    end
end



function clearJustCapturedByAIFlags()
    -- print("clear justCaptureFlags")
    displayJustCapturedMsg = false
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.justCapturedByAI = false
    end
end

function clearJustCapturedWhiteFlags()
    displayJustCapturedMsg = false
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.justCapturedWhite = false
    end
end

function clearJustCapturedBlackFlags()
    displayJustCapturedMsg = false
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.justCapturedBlack = false
    end
end
function clearAiStoneFlags()
    -- print("clearAiStoneFlags")
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.aiStoneFlag = false
    end
end

function clearJustMovedFlags()
    -- print("clearAiStoneFlags")
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.justMovedFlag = false
    end
end


function clearChoiceStoneFlags()
    -- print("clearAiStoneFlags")
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.choiceStoneFlag = false
    end
end

function clearAdvanceStoneFlags()
    -- print("clearAdvanceStoneFlags")
    for i=1, numSquares do
       local bs = bsTable[i]
        bs.advanceStoneFlag = false
    end
end
-- assume boardDiam of 13
lv1Table = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, -- 1st row in order
    48, 14, 47, 15, 46, 16, 45, 17, 44, 18, 43, 19, 42, -- midle rows 1st and last col of level
    20, 41, 21, 40, 22, 39, 23, 38, 24,
    37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25 -- top row in reverse order
    
}

lv2Table = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, -- 1st row in order
    40, 12, 39, 13, 38, 14, 37, 15, 36, 16, -- middle cols 1 pos from edge
    35, 17, 34, 18, 33, 19, 32, 20, 
    31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21
}
   

lv3Table = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, -- 1st row in order
    32, 10, 31, 11, 30, 12, 29, 13,
    28, 14, 27, 15, 26, 16,
    25, 24, 23, 22, 21, 20, 19, 18, 17
}

lv4Table = {
    1, 2, 3, 4, 5, 6, 7,
    24, 8, 23, 9, 22, 10,
    21, 11, 20, 12,
    19, 18, 17, 16, 15, 14, 13
}

lv5Table = {
    1, 2, 3, 4, 5,
    16, 6, 15, 7,
    14, 8,
    13, 12, 11, 10, 9
}

lv6Table = {
    1, 2, 3, 
    8, 4,
    7, 6, 5
  
}

-- although there may be an algorithm, a table mapping the top indexes
-- in level 2 to the indexes of level 1
lv1TopTable = {
    1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11,
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 21,
    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 31,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 1
}

-- level 3 indexes that are top neighbors of lv 2
lv2TopTable = {
    1, 1, 2, 3, 4, 5, 6, 7,  8, 9, 9,
    9, 10, 11, 12, 13, 14, 15, 16, 17, 17,
    17, 18, 19, 20, 21, 22, 23, 24, 25, 25,
    25, 26, 27, 28, 29, 30, 31, 32, 1
}

-- level 4 indexes that are top neighbors of lv 3
lv3TopTable = {
    1, 1, 2, 3, 4, 5, 6, 7, 7,
    7, 8, 9, 10, 11, 12, 13, 13,
    13, 14, 15, 16, 17, 18, 19, 19,
    19, 20, 21, 22, 23, 24, 1
}

-- level 5 indexes that are top neighbors of lv 4
lv4TopTable = {
    1, 1, 2, 3, 4, 5, 5,
    5, 6, 7, 8, 9, 9, 
    9, 10, 11, 12, 13, 13,
    13, 14, 15, 16, 1
}

-- level 6 indexes that are top neighbors of lv 5
lv5TopTable = {
    1, 1, 2, 3, 3,
    3, 4, 5, 5,
    5, 6, 7, 7,
    7, 8, 1
}

-- level 7 indexes that are top neighbors of lv 6
-- there is only 1 square on the top level
lv6TopTable = {
    1, 1, 1, 1,
    1, 1, 1, 1
}


--# GameBoard
GameBoard = class()

manuallyDragBlackStone=false
manuallyDragWhiteStone=false
manuallyDropStoneFlag=false
theDraggedBoardSquare=nil
function GameBoard:init()
    print("Gameboard init")
    -- you can accept and set parameters here
    -- resetBsTable()
    -- displayMode(STANDARD)
    -- displayMode(FULLSCREEN)
    collectgarbage()
        collectgarbage()
        collectgarbage()
    pauseAIvsAI=false
    self:initGameboardSize()
    createBoard()
    self.levelIndexTable = self:createLevelIndexTable()
    -- captured stones play no part in determining winner, but we track
    self.whiteStonesCaptured = 0
    self.blackStonesCaptured = 0   
    self.gameSaveName= "saveme"
    self.saveGameDialog = SaveGameDialog(self.gameSaveName)
    -- dumpBsTable()
    self.showBsIndex=true
    populateNeighbors()
    self:initializeMainPanelButtons()
    self.triggerAIFirstMove = false
    self.hasHandicap=false
    -- sprite("Documents:blackstone_jmage")
    -- sprite("Documents:whitestone_image")
    -- for manual play
    local stImageSz=75

    self.playerCircle = nil
    -- local x,y = 0,0
    local x= xStart -135
    local y = yStart + squareOffset*6
    local c=saddlebrownColor
    local len=65
    self.blackHexContainer = HexContainer(x,y,len,c,2)
    x= xStart + squareOffset*14 + 35
    self.whiteHexContainer = HexContainer(x,y,len,c,3)
    self.blackHexContainer.action=function() self:blackManualPlayModeTouched() end
    self.whiteHexContainer.action=function() self:whiteManualPlayModeTouched() end
    self.stoneDiam= squareSize - 8
    self.stoneX = 0
    self.stoneY = 0
    -- theee use meshcircle to creste 3D type stob
    self.blackStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.whiteStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
    if (gameState == GAMESTATE_NEW
    or gameState == GAMESTATE_BEGIN) then
        if isAIBlackPlayerMode() then
            print("AI Black making first move")
            self.triggerAIFirstMove = true
        elseif isAIWhitePlayerMode() then
            print("AI White: waiting for black to move")
        elseif isAIvsAIPlayerMode() then
            print("AI vs AI Black making first move")
            self.triggerAIFirstMove = true
        else
            print("2 player or manual game")
        end
    end
    self.playLevelChangedMP = MessagePanel("Playlevel Changed")
    self.playLevelChangedMP.msgType=MESSAGE_PANEL_ALERT
    self.gameIsWonMP = MessagePanel("We Have a Winner!")
    self.gameIsWonMP.y = self.gameIsWonMP.y + 136
    self.gameIsWonMP.msgType=MESSAGE_PANEL_ALERT
    self.gameIsWonMP.active=false   
    self.confirmLoseExistingMP = MessagePanel("Existing Game will be lost. Is this OK?")
    self.confirmLoseExistingMP.action = function() theMenuPanel:newBoard() end 
    passMoveFloatingMP=MessagePanel("passing Move")
    passMoveFloatingMP.msgType=MESSAGE_PANEL_FLOATING
    passMoveFloatingMP.y=HEIGHT- 70
    passMoveFloatingMP.action = function() conditionalPassMove() end
    local handicap = theSettings.currentHandicap
    if handicap ~= "None" then
        self.hasHandicap=true
        self:addHandicapStones()
        self.triggerAIFirstMove = false
    end
    self.logDialog=LogDialog()
    self.logCopiedMP = MessagePanel("Log is copied to the clioboard")
    self.logCopiedMP.msgType=MESSAGE_PANEL_ALERT
end

function GameBoard:initializeMainPanelButtons()
    -- undoButton = Button("Undo")
    -- undoButton.action = function () undoMove() end
    local iconSize=34
    
    pauseButton = ImageTextButton("Documents:pause_icon","Documents:pause_icon",0,0,"pause")
    pauseButton.action = function () pauseAIvsAI=true end
    pauseButton.w=iconSize
    pauseButton.h=iconSize
    
    resumeButton = ImageTextButton("Documents:resume_icon","Documents:resume_icon",0,0,"resume")
    resumeButton.action = function () pauseAIvsAI=false end
    resumeButton.w=iconSize
    resumeButton.h=iconSize
       
    undoButton = ImageTextButton("Documents:undo_icon","Documents:undo_icon",0,0,"undo")
    undoButton.action = function () undoMove() end
    undoButton.w=iconSize
    undoButton.h=iconSize
    
    redoButton = ImageTextButton("Documents:redo_icon","Documents:redo_icon",0,0, "redo")
    redoButton.action = function () redoMove() end
    redoButton.w=iconSize
    redoButton.h=iconSize
    
    passButton = ImageTextButton("Documents:pass_icon","Documents:pass_icon",0,0, "pass")
    passButton.w = 42
    passButton.h =32
    passButton.action = function () passMove() end
    
    logButton = ImageTextButton("Documents:log_icon","Documents:log_icon",0,0, "log")
    logButton.w = 36
    logButton.h =38
    logButton.action = function () self:showLog() end
    
    saveButton = ImageTextButton("Documents:save_icon","Documents:save_icon",0,0, "save")
    saveButton.w = 36
    saveButton.h =36
    saveButton.action = function () self:showGameDialog() end
    
    self.gameSavedMP = MessagePanel("Game saved.")
    self.gameSavedMP.msgType = MESSAGE_PANEL_ALERT
    newGameButton= ImageTextButton("Documents:game_icon", "Documents:game_icon",0,0,"new game")
    newGameButton.action = function () self:newGame() end
    newGameButton.w= 36
    newGameButton.h= 36
    -- menuButton = ImageButton("Documents:settings_icon","Documents:settings_icon",0,0)
    menuButton = ImageTextButton("Documents:menu_icon","Documents:settings2_icon",0,0,"menu")
    menuButton.w = 38
    menuButton.h = 38
    menuButton.action = function () showMenuPanel() end  
    
    self.exitButton = ImageTextButton("Documents:exit_icon","Documents:exit_icon",0,0,"exit")
    self.exitButton.action = function () close() end
    self.exitButton.w=36
    self.exitButton.h=36
    self.exitButton.fontColor=whiteColor
    -- self.exitButton.fontSize=ftSize
    
    if isManualPlayMode() then
        undoButton.disabled=true
        redoButton.disabled=true
        passButton.disabled=true
        logButton.disabled=true
        -- saveButton.disabled=true
    else
        undoButton.disabled=false
        redoButton.disabled=false
        passButton.disabled=false
        logButton.disabled=false
        -- saveButton.disabled=false
    end  
end

function GameBoard:draw()
    -- Codea does not automatically call this method
        pushStyle()
    loadingGameInProgressMP:draw()
    drawMessagePanel()
    -- attempt to get rid of captured by ai orphans
    -- which disapear
    
    drawBoard()
    if self.triggerAIFirstMove then
        self.triggerAIFirstMove = false
        if gameHasBeenRestored then
            print("restored game, skippping aifirstmove logic")
            gameHasBeenRestored=false
        else
            self.triggerAIFirstMove = false
            theAIPlayer:move()
            toggleMove()
            gameState=GAMESTATE_INPROGRESS
        end     
    end  
    if manuallyDragBlackStone then 
        moveState=BLACKMOVE
        if CurrentTouch.state == BEGAN or CurrentTouch.state == MOVING then
            self.blackStone.x=CurrentTouch.x - manualOffset
            self.blackStone.y = CurrentTouch.y + manualOffset
            self.blackStone:draw()
            fill(blackColor)
            stroke(blackColor)
            self.playerCircle:draw()
        else
            self:manuallyDropStone(CurrentTouch)
            manuallyDragBlackStone = false
        end
    elseif manuallyDragWhiteStone then 
        moveState=WHITEMOVE
        if CurrentTouch.state == BEGAN or CurrentTouch.state == MOVING then
            self.whiteStone.x=CurrentTouch.x - manualOffset
            self.whiteStone.y = CurrentTouch.y + manualOffset
            self.whiteStone:draw()
            fill(whiteColor)
            stroke(whiteColor)
            self.playerCircle:draw()
        else
            self:manuallyDropStone(CurrentTouch)
            -- tween.delay(.1,function( )manuallyDragWhiteStone = false end)
            manuallyDragWhiteStone = false 
        end
    end
    popStyle()  
    self.gameIsWonMP:draw()
    self.playLevelChangedMP:draw()
    self.saveGameDialog:draw()
    self.gameSavedMP:draw()
    self.logDialog:draw()
    self.logCopiedMP:draw()
    passMoveFloatingMP:draw()
    -- tween.delay(0.3, function() drawBoard() end)
    self.confirmLoseExistingMP:draw()
    if gameState == GAMESTATE_WON then
         self:drawWinningBalls()
        -- tween.delay(5,self:prepWinningBalls())
        -- -tween.delay(5.2,self:winningBalls())
    end
end

function drawBoard() 
    for i=1, numSquares do
        bs = bsTable[i]
        bs:draw()
    end  
    if theSettings.playerMode == isAIPlayerMode() then
        if moveState == theAIPlayer.moveState then
            toggleMove()
        else
        end
    end
    if theSettings.playerMode == MANUALPLAYMODE then
        local x= xStart - 100
        local y = yStart + squareOffset*7
        theGameBoard.blackHexContainer.x=x
        theGameBoard.blackHexContainer.y=y
        theGameBoard.blackHexContainer:draw()     
        local x= xStart + squareOffset*14 + 50
        theGameBoard.whiteHexContainer.x=x
        theGameBoard.whiteHexContainer.y=y
        theGameBoard.whiteHexContainer:draw()
    end      
end

function drawMessagePanel()
    pushStyle()
    pushMatrix()
    local textColor=ivoryColor
    msgColor=ivoryColor
    local x = 0
    local y = HEIGHT - 90
    local x2 = WIDTH
    local y2 = HEIGHT
    local spacer = 55
    fill(lightslategrayColor)
    strokeWidth(0)
    rectMode(CORNERS)
    rect(x,y,x2,y2)
        
    
    if CurrentOrientation == PORTRAIT 
    or CurrentOrientation == PORTRAIT_UPSIDE_DOWN then
        y = y+7
    else         
        fill(ivoryColor)
        fontSize(36)
        font("HoeflerText-Black")
        x = 20
        y = HEIGHT - 64
        local imgX = x + 76
        local imgY = y + 18
        local w = 175
        local h=75
        -- sprite("Documents:ziggurat _image3",imgX,imgY,w, h)
        sprite("Documents:Ziggurat_image1",imgX,imgY,w,h)
        textMode(CORNER)
        text(gameName, x, y)    
        x=WIDTH/2 -200
        y = y+7
    end 
    fill(msgColor)
    if # mainInfoMessage == 0 then
        mainInfoMessage = defaultInfoMessage
    end
    y = HEIGHT - 85
    font("HelveticaNeue-Italic")
    fontSize(16)
    textMode(CORNER)
    if CurrentOrientation == PORTRAIT
    or CurrentOrientation == PORTRAIT_UPSIDE_DOWN then
        x=20
    else
        x = WIDTH/4
    end
    
    text(mainInfoMessage, x, y)
    -- print("current font is:",font())
    
    
    fill(textColor)
    y = y + 42
    
    if isAIvsAIPlayerMode() then
        x = x - 35
        if pauseAIvsAI then
            resumeButton.pos = vec2(x, imgY)
            resumeButton:draw()
        else
            pauseButton.pos = vec2(x, imgY)
            pauseButton:draw()
        end
       x = x + 35
    
        
    end
    font("Helvetica-bold")
    -- x = boardCornerX + 58
    moveStr= "Player:"

    text(moveStr, x,  y)

    strokeWidth(2)
    stroke(lightGrayColor)   
    if moveState==WHITEMOVE then
        fill(whiteColor)
    else
        fill(blackColor)
    end
    if isManualPlayMode() then
        fill(grayColor)
    end
    imgTxtOffset=11
    -- x = x + textSize(moveStr) - 6
    x = x + 72
    imgY=y+9
    theGameBoard.playerCircle  = Circle(x, imgY,30)
    theGameBoard.playerCircle:draw()
    
    imgY=y
    
    fill(textColor)
    x = x + 55
    undoButton.pos = vec2(x, imgY)
    undoButton:draw()
    
    x = x + 50
    redoButton.pos = vec2(x, imgY)
    redoButton:draw() 
    
    x = x + 50
    passButton.pos = vec2(x, imgY)
    passButton:draw()    
    x = x + 50
    logButton.pos = vec2(x, imgY)
    logButton:draw()
    
    x = x + 50
    saveButton.pos = vec2(x, imgY)
    saveButton:draw()  
    
    x = x + 50
    y = y - 4
    text("Level : "..currentPlayLevel, x, y + 10)
    text("Turn #: "..currentTurnNumber, x, y -10) 
    
    x = x + 70
    strokeWidth(0)
    fill(globalColorTable[currentPlayLevel]) -- was nil at a level 4 orn5 
    rectMode(CORNER)
    imgY=y+12
     rect(x, imgY, 14, 14) 
    
    


    fill(textColor)
    x = x + 30
    text("Captured ", x, y + 10)
    local s = string.format("W:%3d  B:%3d",theGameBoard.whiteStonesCaptured,theGameBoard.blackStonesCaptured)
    text(s,x,y-10)
     
    x = x + 130
    y = y + 4
    
       imgY=y
    newGameButton.pos = vec2(x, imgY )
    newGameButton:draw()
    x = x + 60
    menuButton.pos = vec2(x, imgY)
    menuButton:draw()
    
    x = x + 60
    theGameBoard.exitButton.pos = vec2(x, imgY)
    theGameBoard.exitButton:draw()
    
    popMatrix()
    popStyle()  
end

function GameBoard:touched(touch)
    if pauseAIvsAI then
        resumeButton:touched(touch)
    else
        pauseButton:touched(touch)
    end

    if moveIsInProgress then     
        return
    end
    if theGameBoard.saveGameDialog.active then
        theGameBoard:handleSaveGameDialogTouched(touch)       
        -- if dialog is active, don't fall thru
        return
    end  
    if isManualPlayMode() then
        goto zbuttonstart     
    end
    if theGameBoard.logDialog.active then
        theGameBoard.logDialog:touched(touch)
        return
    end
    if passMoveFloatingMP.active then
        passMoveFloatingMP:touched(touch)
        return
    end
    if theGameBoard.gameIsWonMP.active then
        theGameBoard.gameIsWonMP:touched(touch)
        return
    end
    if theGameBoard.playLevelChangedMP.active then
        theGameBoard.playLevelChangedMP:touched(touch)
        return
    end
    -- print("main:touched moveState:"..moveState)
    if moveState == GAMEOVER then 
        -- with Move class we should be able to do undo
        -- also need to touch settings etc
        -- print("game over - only some available")
        if undoButton:touched(touch) then
            return
        elseif logButton:touched(touch) then
            return
        elseif saveButton:touched(touch) then
            return
        elseif newGameButton:touched(touch) then
            return
        elseif menuButton:touched(touch) then
            return
        else
            mainInfoMessage = "Game Over. only certain buttons available"
        end
        return
    end    
    mainInfoMessage = ""
    if touch.state == ENDED then
        good = true
    else
        goto zbuttonstart
    end
    if chooseStoneAdvanceState then
        print("chooseStoneAdvanceState true")
        boardChangedState = false
        -- print("skipping current logic")
        if next(advanceStonesTable) == nil then
            -- if table is empty, do nothing and reset (shouldnt happen)
            print("advanceStonesTable empty")
            chooseStoneAdvanceState = false
            goto zbreak
        end
        sz = # advanceStonesTable     
        for i = 1, sz do
            local bs = advanceStonesTable[i]
            print("checking advanced choice board square")
            -- print("bs")
            print("bs level,index:"..bs.level..","..bs.index)
            bs:touched(touch)       
        end    
        if boardChangedState then
            -- chooseStoneAdvanceState = false
            if theSettings.gameSoundOn then
                -- sound(SOUND_JUMP, 12737)
                makeAdvanceSound()
            end
            clearStoneChooseFlags()
            advanceStonesTable = {}
            -- displayJustCapturedMsg=false
            print("choice made returning after advanceStonesTable check")
            -- the choice may result in other changes
            chooseStoneAdvanceState = false
            while boardChangedState do
                boardChangedState = false
                checkBoardForCapturesAndAdvancements()
            end
            if chooseStoneAdvanceState then
                -- alert("chooseStoneAdvanceState reset to true")
                print("chooseStoneAdvanceState reset to true")
                return
            end
            addMoveToTheMoveTable()
            toggleMove()
            checkStateOfTheBoard()
            checkBoardForCapturesAndAdvancements()
            return
        else
            print("No stone chosen -- returning after advanceStonesTable check")
            return
        end         
    end
    ::zbreak::
    -- if button performs action it returns true -  skip the rest of touch logic
    ::zbuttonstart::
    
    if undoButton:touched(touch) then
        return
    elseif redoButton:touched(touch) then
        return
    elseif passButton:touched(touch) then
        return
    elseif logButton:touched(touch) then
        return
    elseif saveButton:touched(touch) then
            return
    elseif newGameButton:touched(touch) then
        return
    elseif menuButton:touched(touch) then
        return
    elseif theGameBoard.exitButton:touched(touch) then
        return
    end
    if isManualPlayMode() then
        gameState=GAMESTATE_INPROGRESS
        self:manualPlayModeTouched(touch)
        return
    end
        -- buttons & manualplay want all jogic, the rest only care about. ended
    if touch.state == ENDED then
        good = true
    else
        return
    end    
    loX = xStart
    hiX = xStart + boardPixelDiam
    loY = yStart
    hiY = yStart + boardPixelDiam
    if touch.x > loX and touch.x < hiX and touch.y > loY and touch.y < hiY then
        print("touch hit the board")
    else
        -- print("touch outside the board")
        mainInfoMessage=("Point selected outside the game board.")
        return
    end
    clearAiStoneFlags()
        clearJustMovedFlags()
    clearChoiceStoneFlags()
    clearAdvanceStoneFlags()
    clearJustCapturedByAIFlags()
    -- theGameBoard:touched(touch)
    self:handleTouched(touch)
end

function GameBoard:handleTouched(touch)
    -- Codea does )not automatically call this method
    print("gameBoard touched. moveState: "..moveState)
    if self.logCopiedMP.active then
        self.logCopiedMP:touched(touch)
        return
    end
    if self.logDialog.active then
        self.logDialog:touched(touch)
        return
    end
    if self.gameSavedMP.active then
        self.gameSavedMP:touched(touch)
        return
    elseif self.confirmLoseExistingMP:touched(touch) then
        return
    end
    -- touch each board square
    boardChangedState = false
    doAddToUndo=false
    -- tentaviely capture state of grid
    addMoveToTheMoveTable()
    for i=1, numSquares do
        bs = bsTable[i]
        -- do a level check here
        if bs.level < currentPlayLevel then
            goto zcontinue
        end
        bs.drawStoneCounter=0
        bs:touched(touch)
        ::zcontinue::
    end  
    if boardChangedState then
        print("board changed state")
        gameState=GAMESTATE_INPROGRESS

    else
        -- no change, so remove our tentative state from undo table   
        if displayJustCapturedMsg then
            mainInfoMessage="You cannot immediately capture a stone that has just captured you"
            displayJustCapturedMsg = false
        else
            mainInfoMessage = "No gameboard square selected"
        end
        -- remove tentative addition to undo
        table.remove(theMoveTable, 1)
        return
    end 
    -- now we check for capture and advancements
    while boardChangedState do 
        boardChangedState = false
        checkBoardForCapturesAndAdvancements()
    end
    if chooseStoneAdvanceState then
        mainInfoMessage = "You must select which stone to advance before move is complete"
        -- we are in the middle of a move - resolved when
        -- the stone to advance is selected
        table.remove(theMoveTable, 1)

        return
    end

    toggleMove()
    -- checkStateOfTheBoard looks for legal moves for both players
    -- And looks for a stone on the too level -- aka we have a winner
    checkStateOfTheBoard()
end 

function GameBoard:sizeChanged(newWidth, newHeight) 
    self:initGameboardSize()
    self:initializeMainPanelButtons()
    self:repositionBoard()
end

function GameBoard:initGameboardSize()
    if theSettings.gameBoardSize == LARGE_GAMEBOARD_SIZE then
        squareSize = LARGE_SQUARESIZE
    elseif theSettings.gameBoardSize == MEDIUM_GAMEBOARD_SIZE then
       squareSize = MEDIUM_SQUARESIZE
    elseif theSettings.gameBoardSize == SMALL_GAMEBOARD_SIZE then
        squareSize = SMALL_SQUARESIZE
    end
    squareOffset = squareSize - 1
end

function GameBoard:manuallyDropStone(touch)
    print("manuallyDropStone")
    loX = xStart
    hiX = xStart + boardPixelDiam
    loY = yStart 
    hiY = yStart + boardPixelDiam
    -- weve offset stone for visibikitt
    local sz=squareSize
    xTouch=touch.x - manualOffset + sz/2
    yTouch=touch.y + manualOffset + sz/2
    -- xTouch=touch.x - manualOffset
    -- yTouch=touch.y + manualOffset
    local draggedBS=nil
    if theDraggedBoardSquare ~= nil then
        draggedBS=theDraggedBoardSquare
        print("set draggedBS")
        print(draggedB)
    end
    if xTouch > loX and xTouch < hiX and yTouch > loY and yTouch < hiY then
        print("manuallyDropStone touch hit the board")
        manuallyDropStoneFlag=true
        for i=1, numSquares do
            bs = bsTable[i]
            bs:manualDropTouched(xTouch, yTouch)
        end
        manuallyDropStoneFlag=false
    else
        print("manuallyDropStone  touch outside the board")
        -- may want to calculate captures     
    end
    if draggedBS ~= nil then
        printBSInfo("setting draggedBS to empty",draggedBS)
        draggedBS.stoneState=EMPTYSTONESTATE  
        if theSettings.gameSoundOn then
            makeCaptureSound()
        end
        theDraggedBoardSquare=nil
    end
end


winningBallsTable={}
function GameBoard:drawWinningBalls()
    print("GameBoard:drawWinningBalls()")
    local wbColorTable ={
    redColor,
    greenColor,
    blueColor,
    cyanColor,
    yellowColor
    }
    pushStyle()
    local sz = #winningBallsTable
    stroke(whiteColor)
    strokeWidth(4)
    local cIdx=1
    for i=1, sz do
        local winBall=winningBallsTable[i]    
        fill(wbColorTable[cIdx])
        cIdx = cIdx + 1
        if cIdx > 5 then
            cIdx=1
        end
        winBall:draw()
    end
    popStyle()
end

function GameBoard:prepWinningBalls()
    print("prepWinningBalls")
    local cx=WIDTH/8
    local cy = 0
    local size1=50
    local size2=300
    local destX=cx
    local destY=HEIGHT+size2*2
    local duration=2.5
    for i=1, 21 do 
        local winBall=Circle(cx,cy,size1) 
        tween(duration, winBall, {x=destX,y=destY,size=size2}, tween.easing.linear)
        winningBallsTable[i]=winBall
        cx = cx + WIDTH/8
        destX=cx
        if i%2==0 then
            destX=cx+WIDTH/3
        else
            destX=cx-WIDTH/3
        end
        duration = duration + 0.33333
        if duration > 8.0 then
            duration=2.5     
        end
        if i % 7 == 0 then 
            if i % 2 == 0 then 
                cx = WIDTH/16
            else
                cx = WIDTH/8 + WIDTH/16
            end
        end
    end
    local cy = HEIGHT

    local destY=0-size2*2
    
    for i=22, 42 do 
        local winBall=Circle(cx,cy,size1) 
        tween(duration, winBall, {x=destX,y=destY,size=size2}, tween.easing.linear)
        winningBallsTable[i]=winBall
        cx = cx + WIDTH/8
        destX=cx
        if i%2==0 then
            destX=cx+WIDTH/3
        else
            destX=cx-WIDTH/3
        end
        duration = duration + 0.33333
        if duration > 8.0 then
            duration=2.5     
        end
        if i % 7 == 0 then 
            if i % 2 == 0 then 
                cx = WIDTH/16
            else
                cx = WIDTH/8 + WIDTH/16
            end
        end
    end
    
end           




function GameBoard:handleSaveGameDialogTouched(touch)
    local saveIt = self.saveGameDialog:touched(touch)
    if saveIt then
        if currentMove.bs == nil then
            print("handlesave:currentMove.bs nil, skipping addMove")
        else
             print("handlesave:currentMove.bs ok, adding to move table")
            addMoveToTheMoveTable() -- needed torestore
        end
        self:saveGame(self.saveGameDialog.gameName)
        local s = string.format("saved")
        -- self.logSavedMP.message=s
        -- self.logSavedMP.active=true
      table.remove(theMoveTable, 1) -- get board back to current state
        
        
    end
end

function GameBoard:manualPlayModeTouched(touch)
    -- self.blackStoneSelectButton:touched(touch)
    -- self.whiteStoneSelectButton:touched(touch)
    self.blackHexContainer:touched(touch)
    self.whiteHexContainer:touched(touch) 
    if self.gameSavedMP.active then
        self.gameSavedMP:touched(touch)
        return
    elseif self.confirmLoseExistingMP:touched(touch) then
        return
    end
    if manuallyDragBlackStone or manuallyDragWhiteStone then
        -- print("gameboard manually touch WITH drag")
        return
    end
    -- print("gameboard manually touch w/o drag")
    for i=1, numSquares do
        bs = bsTable[i]
        bs.drawStoneCounter=0
        bs:manualPlayModeTouched(touch)
    end  
end


function GameBoard:blackManualPlayModeTouched()
    -- print("blackManualPlayModeTouch")
    if CurrentTouch.state == BEGAN then
        manuallyDragBlackStone=true
    elseif CurrentTouch.state == MOVING then
        manuallyDragBlackStone=true
    elseif CurrentTouch.state == ENDED then
        -- manuallyDragBlackStone=false
    end
    -- print(manuallyDragBlackStone)
end

function GameBoard:whiteManualPlayModeTouched()
    -- print("whiteManualPlayModeTouch")
if CurrentTouch.state == BEGAN then
        manuallyDragWhiteStone=true
    elseif CurrentTouch.state == MOVING then
        manuallyDragWhiteStone=true
    elseif CurrentTouch.state == ENDED then
        -- manuallyDragWhiteStone=false
    end
end

-- moving functions from main for refactoring + createBoard etc



function showMenuPanel()
    print("showMenuPanel")
    -- alert("Show Settings Panel")
    screenState = MENU_SCREEN
    
end

function GameBoard:showGameDialog()
    print("showGameDialog")
    -- alert("Save Game Dialog")
    local tmStr = os.date("_%G_%m%d_%H%M")
    -- we add ".zlog" extension when saved, to filter for list
    self.gameSaveName= string.format("zgame%s", tmStr)
    self.saveGameDialog = SaveGameDialog(self.gameSaveName)
    self.saveGameDialog.active = true
end

function GameBoard:saveGame(name)
    -- local saveGameTable = self:serializeMoveTable
    if isManualPlayMode() then
        theMoveTable={}
        currentMove=Move(1,BLACKMOVE)
        addMoveToTheMoveTable()
    end
    local gmSerlzr = GameSerializer()
    jstr = gmSerlzr:serializeCurrentGame()
    pasteboard.copy(jstr)
    local ext = self.saveGameDialog.gameExt
    local gameName = string.format("%s%s",name,ext)
    saveLocalData(gameName,jstr)

    local s =string.format("Current game saved as \"%s\".", name)
    self.gameSavedMP.message=s
    self.gameSavedMP.active=true
    dumpLocalDataKeys()
        
end

function GameBoard:newGame()
    print("new game - gamestate "..gameState)
    print("new game - playerMode "..theSettings.playerMode)
    if gameState == GAMESTATE_INPROGRESS then
        -- alert("Need confirm to destroy game in progress")
        print("new - game in progress")
        self.confirmLoseExistingMP.active = true
        return
    else
        theAIPlayer = AIPlayer()
        createNewGameBoard()
    end
    
    screenState = GAMEBOARD_SCREEN
end
function GameBoard:handleJsonException(a,b,c,d,e)
    print("handleJsonExcep..")
    print(a) 
    print(b)
    print(c)
    print(d)
    print(e)  
end

function GameBoard:showLog()
    print("showLog logic here")
    self.logDialog:createLogText()
    self.logDialog.active=true  
    
    -- dumpMoves()
    --[[
    theLogPanel:createLogText()
    theLogPanel.logDescription = theLogPanel.logCurrentDesc
    screenState = LOG_SCREEN
      ]]
end

-- on level change we need to recheck for ai opponent
function conditionalPassMove()
    -- alert("conditionalPassMove()")
    print("conditionalPassMove()")
    if moveState == BLACKMOVE and blackPlayableCount > 0 then
        return -- dont pass
    elseif moveState == WHITEMOVE and whitePlayableCount > 0 then
        return
    end
    passMove()
end

function passMove()
    print("passMove - moveState:"..moveText[moveState])
    passedMoveFlag=true
    clearAiStoneFlags() -- normally done on touch
    clearChoiceStoneFlags()
    clearAdvanceStoneFlags()
    currentMove.pass = true
    addMoveToTheMoveTable()
    passMoveFloatingMP.active=false

    if isAIvsAIPlayerMode() then
        print("AIvsAI: calling togglemove from pass")
        toggleMove()
    elseif isAIPlayerMode()
    and moveState == theAIPlayer.moveState then
        print("skip toggle move for passing AIPlayer")
        -- currentTurnNumber = currentTurnNumber + 1
        
    else
        print("calling togglemove from pass")
        toggleMove()
    end
end

function GameBoard:repositionBoard() 
    -- call after sizeChange
    print("GameBoard:repositionBoard()")
    x = xStart
    y = yStart
    resetLevelIndexes()
    k = 1
    for i=1, boardDiam do
        for j = 1, boardDiam do
            -- print("insert square into table at pos: "..k.." level, index: "..level..","..index)
            level = getBoardLevel(i,j)
            index = getNextLevelIndex(level)
            bs = getBoardSquareByLevelIndex(level,index)   
            bs.x=x
            bs.y=y
            bs:initStones(x,y)
            x = x+squareOffset
        end
        x = xStart
        y = y + squareOffset
    end
    boardCornerX = x
    boardCornerY = y
    
end

function createBoard()
    print("BEGIN createBoard")
    print("width: " .. WIDTH)
    print("height: "..HEIGHT) 
    x = xStart
    y = yStart
    bsTable={}
    k = 1
    for i=1, boardDiam do
        for j = 1, boardDiam do
            level = getBoardLevel(i,j)
            index = getNextLevelIndex(level)
            -- print("insert square into table at pos: "..k.." level, index: "..level..","..index)
            bs = BoardSquare(level, index,x,y)
            
            bsTable[k] = bs
            x = x+squareOffset
            k = k+1
        end
        x = xStart
        y = y + squareOffset
    end
    boardCornerX = x
    boardCornerY = y
    print("END createBoard")
    if theSettings.gameSoundOn then
        if gameIsBeingRestored then
            -- suppress sound during restore
        else
            sound(SOUND_POWERUP, 12734)
        end
    end
end

function GameBoard:addHandicapStones()
    local handicap = theSettings.currentHandicap
    if handicap == "None" then
        -- shoulnt happen
        return
    else
        -- fall thru until we hit handicap
        local bs = getBoardSquareByLevelIndex(1,7)   
        bs:setStoneState()
        currentMove:addHandicap(bs)
        local bs = getBoardSquareByLevelIndex(1,31)
        bs:setStoneState()
        currentMove:addHandicap(bs)
        if handicap == 2 then
            return
        end
        -- fall thru, add more     
        bs = getBoardSquareByLevelIndex(1,43)   
        bs:setStoneState()
        currentMove:addHandicap(bs)
        if handicap == 3 then
            return
        end
        local bs = getBoardSquareByLevelIndex(1,19)
        bs:setStoneState()
        currentMove:addHandicap(bs) 
        if handicap == 4 then
            return
        end
        bs = getBoardSquareByLevelIndex(1,1)   
        bs:setStoneState()
        currentMove:addHandicap(bs)
        if handicap == 5 then
            return
        end
        local bs = getBoardSquareByLevelIndex(1,25)
        bs:setStoneState()
        currentMove:addHandicap(bs) 
        if handicap == 6 then
            return
        end
        bs = getBoardSquareByLevelIndex(1,37)   
        bs:setStoneState()
        currentMove:addHandicap(bs)
        if handicap == 7 then
            return
        end
        local bs = getBoardSquareByLevelIndex(1,13)
        bs:setStoneState()
        currentMove:addHandicap(bs) 
        if handicap == 8 then
            return
        end
        -- that's all, folks!
    end
    
end

function GameBoard:createLevelIndexTable(boardSquareTable) 
    local levelIndexTable = {}
    for i=1, 7 do
        levelIndexTable[i] = {}
    end
    for i=1, numSquares do
        local bs = bsTable[i]
        -- print(bs)0
        -- print(bs.level) 
        -- print(bs.index)
        levelIndexTable[bs.level][bs.index] = bs
    end
    return levelIndexTable
end


function populateNeighbors()
    -- add right, left and too neighbors to each square
    -- algorithm is inefficient, could be refactore if a problem
    -- print("BEGIN populateNeighbors")
    for i=1, numSquares do  
        -- print("processing i: "..i)
        local bs = bsTable[i]
        if bs.level == numlevels then
            cool=99 -- top level has no neighbors
        else
            rnLevel = bs.level
            rnIndex = bs.index + 1
            lnLevel = bs.level
            lnIndex = bs.index - 1
            -- adjust for boundariesk
            numIndexes = (7 -bs.level) * 2 * 4
            if rnIndex > numIndexes then
                rnIndex = 1
            end
            if lnIndex < 1 then
                lnIndex = numIndexes
            end
            
            bs.rightNeighbor = getBoardSquareByLevelIndex(rnLevel, rnIndex)
            bs.leftNeighbor = getBoardSquareByLevelIndex(lnLevel, lnIndex)
            -- print("populate neighbors for level, index:"..bs.level..","..bs.inindexdex)
            -- print(bs.rightNeighbor)
            -- print(bs.leftNeighbor)
            -- get the top level
            local topLevel = bs.level + 1
            local topIndex = getTopIndex(bs.level, bs.index)
            bs.topNeighbor = getBoardSquareByLevelIndex(topLevel, topIndex)
        end
    end
    -- print("END populateNeighbors")
end


function getTopIndex(level, index) 
    -- print("getTopIndex:"..level..","..index)
    if level == 1 then
        return lv1TopTable[index]
    elseif level == 2 then
        return lv2TopTable[index]
    elseif level == 3 then
        return lv3TopTable[index]
    elseif level == 4 then
        return lv4TopTable[index]
    elseif level == 5 then
        return lv5TopTable[index]
     elseif level == 6 then
        -- level 7 has only one square which id the top 
        -- for all lv 6
        return 1
    end
    return 99
end


function getBoardSquareByLevelIndex(level, index)
        -- we'd need a new structure to make this more efficient
    -- print("getBoardSquareByLevelIndex: "..level..","..index)
    for i=1, numSquares do
        local bs = bsTable[i]
        if bs == nil then
            goto continue
        end     
        if bs.level == level and bs.index == index then
            return bs
        end
        ::continue::
    end
    -- fall through, shouldn't happen
    print("getBoardSquareByLevelIndex fall thru - level:"..level.." index:"..index)
    return nil
end



function getBoardLevel(row, col)
    l = 0
    if row == 1 or row == boardDiam or
    col == 1 or col == boardDiam then
        l = 1
    elseif row == 2 or row == boardDiam - 1 or
    col == 2 or col == boardDiam - 1 then
        l = 2
    elseif row == 3 or row == boardDiam - 2 or
    col == 3 or col == boardDiam - 2 then
        l = 3
    elseif row == 4 or row == boardDiam - 3 or
    col == 4 or col == boardDiam - 3 then
        l = 4
    elseif row == 5 or row == boardDiam - 4 or
    col == 5 or col == boardDiam - 4 then
        l = 5
    elseif row == 6 or row == boardDiam - 5 or
    
    
    col == 6 or col == boardDiam - 5 then
        l = 6
    elseif row == 7 or row == boardDiam - 6 or
    
    col == 7 or col == boardDiam - 6 then
        l = 7   
    else
        l=8
    end
    return l
end

-- step 1 -look for a winner
-- step 2 - look for open squares on current level for each player
function checkStateOfTheBoard()
    print("checkStateOfTheBoard")
    checkForWinner()
    if moveState == GAMEOVER then 
        return
    end
    checkCurrentPlayLevel()
    checkForOpenSquares()
end

function checkForWinner ()
    for i=1, numSquares do
        bs = bsTable[i]
        -- do we have a winner ?
        if bs.level == topPlayLevel then
            local winner=""
            local name=""
            theMenuPanel:refreshSettings()
            if bs.stoneState == WHITESTONESTATE then
                winner="White"
                --[[
                if isAIWhitePlayerMode() then
                    name=iPadAiName
                else
                    name=theSettings.whitePlayerName
                end
                  ]]
                moveState=GAMEOVER
                gameState=k
            elseif bs.stoneState == BLACKSTONESTATE then
                winner="Black"
                --[[
                if isAIBlackPlayerMode() then
                    name=iPadAiName
                else
                    name=theSettings.blackPlayerName            
                end
                  ]]
                moveState=GAMEOVER
                gameState=GAMESTATE_WON
            end
            if moveState==GAMEOVER then
                if theSettings.gameSoundOn then              
                    --[[
                    t1=tween.delay(0.3,sound(SOUND_POWERUP, 24870))
                    t2=tween.delay(0.9,  sound(SOUND_RANDOM, 25868))
                    t3=tween.delay(0.3,sound(SOUND_POWERUP, 24870))
                      ]]
                    c1=Circle(1,0,0)
                    local t1 = tween( 0.75, c1, {x = 0}, tween.easing.linear,
                    function() 
                        sound(SOUND_POWERUP, 24870)
                    end )
                    local t2 = tween( 0.75, c1, {x = 0}, tween.easing.linear,
                    function() 
                        sound(SOUND_POWERUP, 24870)
                    end )
                    local t3 = tween( 0.75, c1, {x = 0}, tween.easing.linear,
                    function() 
                        sound(SOUND_POWERUP, 24870)
                    end )
                    local t4 = tween( 0.75, c1, {x = 0}, tween.easing.linear,
                    function() 
                        sound(SOUND_POWERUP, 24870)
                    end )
                    local t5 = tween( 0.75, c1, {x = 0}, tween.easing.linear,
                    function() 
                        sound(SOUND_POWERUP, 24870)
                    end )
                    tween.sequence( t1, t2, t3, t4, t5 )
                end
                theGameBoard:prepWinningBalls()
                
                mainInfoMessage = string.format("%s Wins!!  Congratulations!", winner)
                theGameBoard.gameIsWonMP.active=true
                theGameBoard.gameIsWonMP.message=mainInfoMessage
                return
            end
        end
        -- theSettings.blackPlayerName.." vs "..theSettings.whitePlayerNameoo
        
    end
end




function checkForOpenSquares()
    -- we count number of ooen squares on current level that each player can play
    -- note, if we find at least one playable square formeach plater we break out of loop
    print("checkForOpenSquares")
    whitePlayableCount = 0
    blackPlayableCount = 0
    for i=1, numSquares do
        bs = bsTable[i] 
        if bs:isPlayableSquare(WHITESTONESTATE) then
            whitePlayableCount = whitePlayableCount + 1
        end
        if bs:isPlayableSquare(BLACKSTONESTATE) then
            blackPlayableCount = blackPlayableCount + 1
        end
        
    end
    ::zbreak::
    print("whitePlayableCount: "..whitePlayableCount)
    print("blackPlayableCount: "..blackPlayableCount)
    -- check for perverse
    if whitePlayableCount == 0 and blackPlayableCount == 0 then
        print("no playable squares for either player ")
        checkCurrentPlayLevel()
    end
    if chooseStoneAdvanceState then
        print("skip pass untipmchoosestoneadvance resolved")
    elseif moveState == WHITEMOVE and whitePlayableCount == 0 then
        mainInfoMessage="no playable squares WHITE, forcing pass. "
        -- moveState=BLACKMOVE
        -- local destX=passMoveFloatingMP.x + 8
        print(mainInfoMessage)
        -- alert("no open squares:"..mainInfoMessage)
        if isAIBlackPlayerMode() then
            tween( 2.0, passMoveFloatingMP, {}, tween.easing.linear,
                function() conditionalPassMove() end )
            -- passMoveFloatingMP.message= mainInfoMessage
            passMoveFloatingMP.active=true
        else
            conditionalPassMove()
        end
    elseif  moveState == BLACKMOVE and blackPlayableCount == 0 then
        mainInfoMessage="no playable squares for BLACK, forcing pass.  "
        -- moveState=WHITEMOVE
        -- local destX=passMoveFloatingMP.x + 8
        print(mainInfoMessage)
        -- alert("no open squares:"..mainInfoMessage)  
        if isAIWhitePlayerMode() then
            tween( 1.75, passMoveFloatingMP, {}, tween.easing.linear,
            function() conditionalPassMove() end )
            passMoveFloatingMP.message= mainInfoMessage
            passMoveFloatingMP.active=true
        else
            conditionalPassMove()
        end
        
    end
end

function clearStoneChooseFlags()
    for i=1, numSquares do
        bs = bsTable[i]
        bs.stoneChooseFlag = false
    end
end

function checkBoardForCapturesAndAdvancements()
    -- only check active levels
    print("checkBoardForCapturesAndAdvancements")
    for i=1, numSquares do
        bs = bsTable[i]
        if bs.level < currentPlayLevel then
            goto zcontinue
        end
        -- print("bs.stoneState: "..bs.stoneState)
        if bs.stoneState == EMPTYSTONESTATE then
            -- bs:draw()
            goto zcontinue
        end
        bs:checkForCaptureOrAdvancement()
        checkForWinner()
      ::zcontinue::
    end
end


--[[
  ]]






--# BoardSquare
BoardSquare = class()
EMPTYSTONESTATE = 1
WHITESTONESTATE = 2
BLACKSTONESTATE = 3
stoneStateText = {
    "EMPTYSTONESTATE",
    "WHITESTONESTATE",
    "BLACKSTONESTATE"
}

function BoardSquare:init(level,index,xx,yy)
    -- you can accept and set parameters here
    -- print("BoardSquare:init")
    
    colorTable = {}
    colorTable[1]=redColor
    colorTable[2] = orangeColor
    colorTable[3]  = yellowColor
    colorTable[4]  = greenColor
    colorTable[5]= royalblueColor
    colorTable[6]= indigoColor
    colorTable[7]= purpleColor
    colorTable[8] = whiteColor

    self.stoneChooseFlag = false
    -- for ai play
    self.humanStoneFlag = false
    self.justMovedFlag = false
    self.aiStoneFlag = false
    self.choiceStoneFlag=false
    self.advanceStoneFlag=false
    self.advancingStoneState=self.stoneState
    self.level = level
    self.index = index
    self.stoneState = EMPTYSTONESTATE
    -- neighbors are populated when board is created - checked when a new stone is placed on board
    self.rightNeighbor = nil
    self.leftNeighbor = nil
    self.topNeighbor = nil
    -- handle case where you can.t capture a stone that has just captured your stone
    -- you need to wait one move
    self.justCapturedByAI=false -- used for display
    self.justCapturedWhite=false
    self.justCapturedBlack=false
    self.drawStoneCounter=0
    
        self.c = colorTable[level]
    self:initStones(xx,yy)
    
end

function BoardSquare:initStones(xx, yy)
    self.x = xx
    self.y = yy

    self.w = squareSize
    self.h = squareSize  
   fill(self.c)
    --self.myRect = rect(x,y,w,h)
    --self.myRect:stroke(0)
    toCenter = squareSize/2
    math.floor(toCenter) 
   local ex = xx + toCenter
    local ey= yy + toCenter
    local ew= squareSize - 4
    self.stoneDiam= squareSize - 8
    self.stoneX = xx + 4
    self.stoneY = yy + 4
    -- theee use meshcircle to creste 3D type stob
    self.blackStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.whiteStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
    n=2 
    self.whiteAdvancedChoiceStone = WhiteStone(self.stoneX-n,self.stoneY-n,self.stoneDiam+4)
    self.blackAdvancedChoiceStone = BlackStone(self.stoneX-n,self.stoneY-n,self.stoneDiam + 4)
    -- stone can clipped by drawing if next square 
    self.blackChoiceStone = BlackStone(self.stoneX,self.stoneY-2,self.stoneDiam)
    self.whiteChoiceStone = WhiteStone(self.stoneX,self.stoneY-2, self.stoneDiam)
    self.blackLastMoveStone = BlackStone(self.stoneX-2, self.stoneY-2,self.stoneDiam+4)
    self.whiteLastMoveStone = WhiteStone(self.stoneX-2,self.stoneY-2,self.stoneDiam+4)
    self.blackAdvancingStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.whiteAdvancingStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.blackAiStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.whiteAiStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.blackAiStoneFirstMove = BlackStone(self.stoneX-2,self.stoneY-2,1)
    self.whiteAiStoneFirstMove = WhiteStone(self.stoneX-2,self.stoneY-2,1) 
    self.lastMoveCircle = Circle(ex, ey, 15)
    self.r = Circle(ex, ey, ew)
    self.blackCapturedStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
    self.whiteCapturedStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
    local destY = self.stoneY +4
    tween( 0.05, self.blackChoiceStone, { y = destY }, { easing = tween.easing.linear,loop = tween.loop.pingpong } )
    tween( 0.05, self.whiteChoiceStone, { y = destY }, { easing = tween.easing.linear,loop = tween.loop.pingpong } )
     
end


function BoardSquare:draw()
    -- Codea does not automatically call this method
    pushStyle()
    if isManualPlayMode() then
        -- dont hulite in manual
        strokeWidth(2)
        stroke(darkGrayColor)    
    elseif currentPlayLevel == self.level and theSettings.highlightCurrentLevel then
        strokeWidth(2)
        stroke(lightestGrayColor) 
    else
        strokeWidth(2)
        stroke(darkGrayColor)     
    end
       
    fill(self.c)
    rect(self.x,self.y,self.w,self.h)
  
    if theSettings.showBoardIndexNumbers then
        font("Inconsolata")
        fontSize(10)
        local xx = self.x +7
        local yy = self.y +7
        fill(blackColor)
        if self.level > 4 then
            fill(whiteColor)
        end
        text(self.index,xx,yy)
    end
    popStyle()
    self:displayStoneState()

    
end



function BoardSquare:touched(touch)
    -- Codea does not automatically call this method
    if self.stoneChooseFlag  or isManualPlayMode()then
        skiplvl = true
    elseif(self.level == currentPlayLevel) then
        cool=7
    else
        -- you can only play on the lowest level with an open square 
        return
    end
    -- print("moveState: "..moveState )

    local loX = self.x
    local hiX = self.x + squareOffset
    local loY = self.y 
    local hiY = self.y + squareOffset
    
    if touch.x > loX and touch.x < hiX and touch.y > loY and touch.y < hiY then
        print("touch hit the square")
        if moveState == WHITEMOVE then
            if self.justCapturedWhite then
                -- print("justcaptured white true so no play")
                displayJustCapturedMsg=true
                return
            end
        elseif moveState == BLACKMOVE then
            if self.justCapturedBlack then
                -- print("justcaptured black true so no play")
                displayJustCapturedMsg=true
                return
            end
        end
    else
        -- print("return no hit")
        return
    end
    
    
    -- a stone has been placed - is it legal?
    --  adjust stone state - maybe
    self:setStoneState()  
end

function BoardSquare:manualPlayModeTouched(touch)
    local loX = self.x
    local hiX = self.x + squareOffset
    local loY = self.y
    local hiY = self.y + squareOffset
    if touch.x > loX and touch.x < hiX and touch.y > loY and touch.y < hiY then
        print("touch hit the square")
        if self.stoneState == EMPTYSTONESTATE then
            return
        elseif self.stoneState == BLACKSTONESTATE then
            manuallyDragBlackStone=true
            -- theDraggedBoardSquare=self
            self.stoneState=EMPTYSTONESTATE
        elseif self.stoneState == WHITESTONESTATE then
            manuallyDragWhiteStone=true
            self.stoneState=EMPTYSTONESTATE
            -- theDraggedBoardSquare=self
        end
    end
end

function BoardSquare:manualDropTouched(xTouch, yTouch)
    if pointInRect(xTouch, yTouch, self.x, self.y, squareOffset, squareOffset) then  
        self:setManualPlayModeStoneState() 
    end
end

function BoardSquare:setManualPlayModeStoneState()
    print("setManualPlayModeStoneState")
    if self.stoneState == EMPTYSTONESTATE then
        if moveState == BLACKMOVE then
            self.stoneState=BLACKSTONESTATE
            if theSettings.gameSoundOn then
                makeStoneClickSound()
            end
        elseif moveState == WHITEMOVE then
            self.stoneState=WHITESTONESTATE
            if theSettings.gameSoundOn then
                -- sound(SOUND_HIT, 12734)
                makeStoneClickSound()
            end
        else
            print("failed to set state")
        end
    end
end

function BoardSquare:setStoneState()
    print("setStoneState - touched: "..self.level..","..self.index)
    if self.stoneChooseFlag then
        print("stoneChooseFlag true, changing states and vamoosing")
        -- clearAdvanceStoneFlags()
        self.drawStoneCounter=0
        self.topNeighbor.stoneState = self.stoneState
        self.topNeighbor.justMovedFlag=true
        self.stoneState = EMPTYSTONESTATE    
        self.stoneChooseFlag = false
        local top = self.topNeighbor
        currentMove:addAdvance(self, top)
        -- top.aiStoneFlag = true
        boardChangedState = true
        -- this is the only thing we're checking   
        return
    end
    -- create new circles
    toCenter = squareSize/2
    math.floor(toCenter)
   local ex = self.x + toCenter
   local ey= self.y + toCenter
   local ew= squareSize - 4
    
    self.aiStone = Circle(ex, ey, 8) 
    -- a pinprick to full size plus stone over the course of 1 or 2 secs
       tween( 1.0, self.aiStone, {size = ew +8}, tween.easing.linear)
    
    self.blackAiStone = BlackStone(self.stoneX+16,self.stoneY+16,8)
    self.blackAiStone.tweening=true
    self.whiteAiStone = WhiteStone(self.stoneX+16,self.stoneY+16,8)
    self.whiteAiStone.tweening=true
    local destX=self.stoneX-2
    local destY=self.stoneY-2
    tween( 1.25, self.whiteAiStone, {diam = self.stoneDiam +4,x=destX,y=destY}, tween.easing.linear)
    tween( 1.25, self.blackAiStone, {diam = self.stoneDiam +4,x=destX,y=destY}, tween.easing.linear)
    -- self.aiStoneFirstMove= Circle(ex, ey, 1) 
    -- a pinprick to full size plus stone over the course of more secs
    -- tween( 13.0, self.aiStoneFirstMove, {size = ew +8}, tween.easing.linear)
    -- tween( 4.0, self.aiStoneFirstMove, {size = ew +8}, tween.easing.quadIn)
    self.blackAiStoneFirstMove = BlackStone(self.stoneX+16,self.stoneY,8)
    self.whiteAiStoneFirstMove = WhiteStone(self.stoneX+16,self.stoneY+16,8)
    self.blackAiStoneFirstMove.tweening=true
    self.whiteAiStoneFirstMove.tweening=true
    tween( 4.0, self.whiteAiStoneFirstMove, {diam = self.stoneDiam +4,x=destX,y=destY}, tween.easing.linear)
    tween( 4.0, self.blackAiStoneFirstMove, {diam = self.stoneDiam +4,x=destX,y=destY}, tween.easing.linear)
        
    state = self:setStoneStateOnTouch(self.stoneState, self.rightNeighbor, self.leftNeighbor)
    if boardChangedState then
        self.justMovedFlag=true
        currentMove.bs = self
    end
    -- ex etc are placements for stone
    self.stoneState = state 
    if theSettings.gameSoundOn then
        -- sound(SOUND_HIT, 12734)
        makeStoneClickSound()
    end
    
end

function BoardSquare:isJustCaptured()
    return self.justCapturedBlack or self.justCapturedWhite
end

function BoardSquare:displayStoneState()
    -- print("displayStoneState")
    toCenter = squareSize/2
    math.floor(toCenter)
    local ex = self.x + toCenter
    local ey= self.y + toCenter
    local ew= squareSize - 4
    if self.stoneState == EMPTYSTONESTATE then
        if theSettings.showCapturingStone
        and self:isJustCaptured() then
            self:drawCapturedStone()
            justCapturedCounter = justCapturedCounter + 1
            if justCapturedCounter > 90 then
                self.justCapturedByAI = false
                -- self.justCapturedBlack=false
                -- self.justCapturedWhite=false
            end
        elseif self.advanceStoneFlag then
            -- self.advancingStoneState=self.stoneState
            tween.delay(0.001,function()   self:drawAdvancingStone() end)       
            -- self:drawAdvancingStone()
        end
        -- nothing to do
        return
    end
    
    strokeWidth(2)
    stroke(grayColor)
    if self.stoneState == WHITESTONESTATE then
        -- print("setting ec to white")
        ec = whiteColor
    elseif self.stoneState  == BLACKSTONESTATE then
        -- print("setting ec to black")
        ec = blackColor
    else
        return
    end
    fill(ec)   
    if moveState == GAMEOVER then  
        -- skip all the flags
        -- self.stone:draw()
        self:drawStone()
    elseif self.stoneChooseFlag then
        -- print("drawing stoneChooseFlag")    
        -- self.choiceStone:draw()
        self:drawChoiceStone()
        
    --[[
    elseif self.humanStoneFlag then
        self.humanStone:draw()       
    elseif self.aiStoneFlag
    and theSettings.showLastMove then
        if theAIPlayer.stoneState ~= self.stoneState then
            -- fix fir stranfe drawing bug
            -- self.stone:draw()
            self:drawStone()
            return
        end     
        -- print("drawing aiStone")  
        if theGameBoard.triggerAIFirstMove then
            -- self.aiStoneFirstMove:draw()
            self:drawAiStoneFirstMove()
        else
            self:drawAiStone()
        end
        self:drawLastMoveCircle()    
         
          ]]
    elseif self.choiceStoneFlag then
        if choiceNukeAICounter < 1 then
            clearAiStoneFlags()
        end
        choiceNukeAICounter = choiceNukeAICounter + 1
        if choiceNukeAICounter == 1 then
            printBSInfo("ec color for choiceStoneFlag", self)
            print(ec)
        end
        -- self.advancedChoiceStone:draw()
        self:drawAdvanceChoiceStone()
        self:drawLastMoveCircle()    
    else
        -- ellipse(ex,ey,ew)
        -- delay drawing an advanced stone until animation is done
        if self.advanceStoneFlag then
            -- advancing stone is arising
            -- if isAIWhitePlayerMode() and 
           if  self.stoneState == WHITESTONESTATE and theSettings.showLastMove then   
                self.advanceLastMoveCounter = self.advanceLastMoveCounter + 1
                if self.advanceLastMoveCounter == 1 then
                    print("advLastStone aiwhiteplay, movest black")
                end
                if self.advanceLastMoveCounter > 24 then
                    self:drawLastMoveStone()
                end
            -- elseif isAIBlackPlayerMode()and
            elseif self.stoneState == BLACKSTONESTATE  and theSettings.showLastMove then
                if self.advanceLastMoveCounter == 1 then
                    print("advLastStone  aiblackplay, movest white")
                end
                self.advanceLastMoveCounter = self.advanceLastMoveCounter + 1
                if self.advanceLastMoveCounter > 24 then
                    self:drawLastMoveStone()
                end
            
            else
                self.advanceLastMoveCounter = self.advanceLastMoveCounter + 1
                if self.advanceLastMoveCounter > 24 then
                    self:drawStone()
                end
                -- tween.delay(0.3, function() self.advanceStoneFlag=false end )
            end
            -- tween.delay(1.3, function() self.advanceStoneFlag=false end )            
        else
            -- self.stone:draw()
            if self.justMovedFlag and theSettings.showLastMove then
                self:drawLastMoveStone()
            else
                self:drawStone()
            end
            
        end
        
    end
end

function BoardSquare:drawCapturedStone()
    -- print("drawCapturedStoene")
    if createNewCaptureStone then
        createNewCaptureStone=false
        -- self.capturedStone = Circle(ex, ey, ew)
        --  full size to 0 over the course of 1 or 2 secs
        print("tween new capturestone")
        -- tween( 1.5, self.capturedStone, {size = 0} , tween.easing.linear)
        
        self.blackCapturedStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
        self.whiteCapturedStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
        self.blackCapturedStone.tweening=true
        self.whiteCapturedStone.tweening=true
        local destX=math.floor(self.stoneX + squareSize/2)
        local destY=math.floor(self.stoneY + squareSize/2)
        print("destX:"..destX)
        tween( 0.75, self.whiteCapturedStone, {diam = 0,x=destX,y=destY} , tween.easing.linear)
        tween( 0.75, self.blackCapturedStone, {diam = 0,x=destX,y=destY} , tween.easing.linear)
    end

    if self.justCapturedWhite then
        print("drsw white captured stone")
        self.whiteCapturedStone:draw()
    elseif self.justCapturedBlack then
                print("drsw black captured stone")
        self.blackCapturedStone:draw()
    else
        self:draw()
    end
end


function BoardSquare:drawAiStoneFirstMove()
    if self.stoneState == WHITESTONESTATE then
        self.whiteAiStoneFirstMove:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackAiStoneFirstMove:draw()
    end
end

function BoardSquare:drawAiStone()
    if self.stoneState == WHITESTONESTATE then
        self.whiteAiStone:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackAiStone:draw()
    end
end

function BoardSquare:drawChoiceStone()
    if self.stoneState == WHITESTONESTATE then
        self.whiteChoiceStone:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackChoiceStone:draw()
    end
end

function BoardSquare:drawAdvanceChoiceStone()
    if self.stoneState == WHITESTONESTATE then
        self.whiteAdvancedChoiceStone:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackAdvancedChoiceStone:draw()
    end
end

function BoardSquare:drawStone()
    if self.stoneState == WHITESTONESTATE then
        self.whiteStone:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackStone:draw()
    end
end

-- this is called with a slight delay so board is completely drawn
function BoardSquare:drawLastMoveStone()
    if self.stoneState == WHITESTONESTATE then
        self.whiteLastMoveStone:draw()
    elseif self.stoneState == BLACKSTONESTATE then
        self.blackLastMoveStone:draw()
    end
    -- self.lastMoveStone:draw()
    -- self:drawLastMoveCircle()
    pushStyle()
    strokeWidth(0)
    fill(redColor)
    self.lastMoveCircle:draw()
    popStyle()
end



function BoardSquare:drawLastMoveCircle()
    pushStyle()
    strokeWidth(0)
    fill(redColor)
    self.lastMoveCircle:draw()
    popStyle()
end

function BoardSquare:drawAdvancingStone()
    if self.createAdvanceImage then
        -- alert("advance stone flag true etc")
        print("creating advance stone")
        self.createAdvanceImage=false
        -- self.advancingStone = Circle(ex, ey, ew)
        self.blackAdvancingStone = BlackStone(self.stoneX,self.stoneY,self.stoneDiam)
        self.whiteAdvancingStone = WhiteStone(self.stoneX,self.stoneY,self.stoneDiam)
        local destX = self.topNeighbor.x +3
        local destY= self.topNeighbor.y + 3
        self.topNeighbor.advanceStoneFlag=true
        -- tween( 0.30, self.advancingStone, {y=destY, x= destX},  tween.easing.linear)
        tween( 0.30, self.blackAdvancingStone, {y=destY, x= destX},  tween.easing.linear)
        tween( 0.30, self.whiteAdvancingStone, {y=destY, x= destX},  tween.easing.linear)
        
    else
        -- tween.delay(0.05, function() self.advancingStone:draw() end)
        
        tween.delay(0.3,function()   self.advanceStoneFlag=false end)
    end
    if self.advancingStoneState == WHITESTONESTATE then
        self.whiteAdvancingStone:draw()
    elseif self.advancingStoneState  == BLACKSTONESTATE then
        self.blackAdvancingStone:draw()
    end
end

function BoardSquare:setStoneStateOnTouch(sstate, rightNeighbor, leftNeighbor)
    -- this square has been touch, do we add stone?
    print("setStoneStateOnTouch. sstate: ")
    print(sstate)
    createNewCaptureStone=true
    self.createAdvanceImage=true
    justCapturedCounter=0
    choiceNukeAICounter=0
    

    local returnState = EMPTYSTONESTATE
    if sstate ==  EMPTYSTONESTATE then
        cool=0
    else 
        return sstate
    end
    if moveState == NOMOVE then
        -- no move
        return state
    end
    
    -- gonna try to put a stone on this guy
    if moveState == WHITEMOVE then
        if (BoardSquare:checkForHostileCapture(WHITESTONESTATE, rightNeighbor, leftNeighbor)) then
            boardChangedState = true
            return WHITESTONESTATE
        elseif (BoardSquare:legalMove(WHITESTONESTATE, rightNeighbor, leftNeighbor)) then
            returnState = WHITESTONESTATE
            boardChangedState = true
        end
    else
        if (BoardSquare:checkForHostileCapture(BLACKSTONESTATE, rightNeighbor, leftNeighbor)) then
            boardChangedState = true
            return BLACKSTONESTATE
        elseif (BoardSquare:legalMove(BLACKSTONESTATE, rightNeighbor, leftNeighbor)) then
            returnState  = BLACKSTONESTATE
            boardChangedState = true
        end
    end
    return returnState
end
-- if square is between 2 opponent stones, you can only place a stone
-- if it can capture one or more of the hostile stones
-- if capture occurs, this fuction changes the state of the squares 
-- holding the hostile stonesin

function BoardSquare:checkForHostileCapture(state, rn, ln)
    -- print("checkForHostileCapture state: "..state)
    -- print("rn.stoneState:"..rn.stoneState.." rn.rightNeighbor.stoneState:"..rn.rightNeighbor.stoneState)
    -- print("ln.stoneState:"..ln.stoneState.." ln.leftNeighbor.stoneState:"..ln.leftNeighbor.stoneState)
    if moveState == BLACKMOVE then
        if state == BLACKSTONESTATE and rn.stoneState == WHITESTONESTATE and ln.stoneState == WHITESTONESTATE then
            -- black stone can capture if neighbor's neighbor is black
            if rn.rightNeighbor.stoneState == BLACKSTONESTATE then
                -- remove the neighbor and return true
                -- print("capturing White right neighbor")
                rn.stoneState = EMPTYSTONESTATE
                rn.justCapturedWhite = true
                if isAIBlackPlayerMode() then
                    rn.justCapturedByAI = true
                end
                theGameBoard.whiteStonesCaptured = theGameBoard.whiteStonesCaptured + 1
                currentMove:addCapture(rn) 
                
                return true
            elseif ln.leftNeighbor.stoneState == BLACKSTONESTATE then
                -- print("capturing white left neighbor")
                ln.justCapturedWhite = true
                if isAIBlackPlayerMode() then
                    ln.justCapturedByAI = true
                end

                theGameBoard.whiteStonesCaptured = theGameBoard.whiteStonesCaptured + 1
                ln.stoneState = EMPTYSTONESTATE
                currentMove:addCapture(ln)
                return true
            end
        end
      elseif moveState == WHITEMOVE then
            if state == WHITESTONESTATE and rn.stoneState == BLACKSTONESTATE and  ln.stoneState == BLACKSTONESTATE then
                -- white stone can capture if neighbor's neughbor is white
            if rn.rightNeighbor.stoneState == WHITESTONESTATE then
                -- remove the neighbor and return true
                -- print("capturing right neighbor")
                rn.justCapturedBlack = true            
                if isAIWhitePlayerMode() then
                    rn.justCapturedByAI = true
                end
                theGameBoard.blackStonesCaptured = theGameBoard.blackStonesCaptured + 1
                rn.stoneState = EMPTYSTONESTATE
                currentMove:addCapture(rn)
                return true
            elseif ln.leftNeighbor.stoneState == WHITESTONESTATE then
                -- print("capturing left neighbor")
                ln.justCapturedBlack = true
                if isAIWhitePlayerMode() then
                    ln.justCapturedByAI = true
                end             
                theGameBoard.blackStonesCaptured =
                theGameBoard.blackStonesCaptured + 1
                ln.stoneState = EMPTYSTONESTATE
                currentMove:addCapture(ln)
                return true
            end
            end
        end
    -- we didn't change the state of anything
    -- print("no hostile capture")j
    return false
end

-- if square is between 2 opponent stones, you can't place a stone 
-- hostile capture situation has to be chexked firsty
function BoardSquare:legalMove(state, rn, ln)
    -- print("legalMove state: "..state)
    if state == BLACKSTONESTATE and rn.stoneState == WHITESTONESTATE and ln.stoneState == WHITESTONESTATE then
        return false
    elseif state == WHITESTONESTATE and rn.stoneState == BLACKSTONESTATE and ln.stoneState == BLACKSTONESTATE then
        return false
    end
    -- fall thru its legal
    return true
end

function BoardSquare:checkForCaptureOrAdvancement()
    -- if both neighbors are opponent srones you are captured
    -- printBSInfo("checkForCaptureOrAdvancement",self)
    -- print("movestate:"..moveState)
    -- print("checkCaptureAdvance stonestate: ")
    -- print(self.stoneState)
    self.advanceLastMoveCounter=0
    if self.stoneState == EMPTYSTONESTATE then
        return
    elseif self.level == topPlayLevel then
        print("stone on top level no more checks")
        moveState=GAMEOVER
        gameState=GAMESTATE_WON
        clearChoiceStoneFlags()
        return
    end
    
    -- BLACKMOVE = 1.  WHITEMOVE = 2
    -- print("checkCaptureAdvance moveState: "..moveText[moveState])
    -- print(self.rightNeighbor)
    -- print(self.leftNeighbor)
    -- print(self.topNeighbor)
    -- lets use some locals for the checks and changes
    local selfState= self.stoneState
    local rn = self.rightNeighbor
    local ln = self.leftNeighbor
    local top = self.topNeighbor
    local aiCheck = false
    --[[
    if self.level==2 and self.index == 11 then
        printBSInfo("checking the neighborhood",self)
        printBSInfo("rightNeighbor",rn)
        printBSInfo("leftNeighbor",ln)
        printBSInfo("topNeighbor",top)
        local s=string.format("movestate:%d.  selfState:%d",moveState,selfState)
        print(s)
    end
      ]]
    if top.stoneState == EMPTYSTONESTATE then
        aiCheck = true
    end
    if moveState == BLACKMOVE then
        if self.stoneChooseFlag then
            -- dont check twice or you will freeze
            return
        end
        if BoardSquare:checkForAdvancementStoneChoice(self, rn, ln, top) then
            -- print("need wait for choice logic")
            -- double check top state
            if top.stoneState == EMPTYSTONESTATE then
                if theSettings.gameSoundOn then
                    makeStoneChoiceSound()
                end
                self.stoneChooseFlag = true
                chooseStoneAdvanceState = true
                boardChangedState=true
                table.insert(advanceStonesTable, self)
                clearAdvanceStoneFlags()
                return
            end
        end
        -- continue with normal logic no matter what
        if selfState == BLACKSTONESTATE and rn.stoneState == BLACKSTONESTATE and
        ln.stoneState == BLACKSTONESTATE then
                self.advancingStoneState=BLACKSTONESTATE
            -- print("check black advance")
            -- need to advance to top neighbor if empty and legal
            if top.stoneState == EMPTYSTONESTATE then
                if (BoardSquare:checkForHostileCapture(BLACKSTONESTATE, top.rightNeighbor, top.leftNeighbor)) then
                    self.stoneState = EMPTYSTONESTATE
                    self.advanceStoneFlag=true
                    top.advanceStoneFlag=true
                    top.stoneState = BLACKSTONESTATE
                    currentMove:addAdvance(self, top)
                    boardChangedState = true
                elseif BoardSquare:legalMove(BLACKSTONESTATE, top.rightNeighbor, top.leftNeighbor)  then
                    self.advanceStoneFlag=true
                    top.advanceStoneFlag=true
                    self.stoneState = EMPTYSTONESTATE
                    top.stoneState = BLACKSTONESTATE
                    currentMove:addAdvance(self, top)
                    boardChangedState = true
                end
            end
        elseif selfState == WHITESTONESTATE and rn.stoneState == BLACKSTONESTATE and
        ln.stoneState == BLACKSTONESTATE then
            -- captured!
            print("white stone captured")
            if isAIBlackPlayerMode() then
                self.justCapturedByAI = true
            end
            self.justCapturedWhite=true
            self.stoneState = EMPTYSTONESTATE
            currentMove:addCapture(self)
            theGameBoard.whiteStonesCaptured = theGameBoard.whiteStonesCaptured + 1
            boardChangedState = true

        end
    end
    
    if moveState == WHITEMOVE then
        -- print("movestate is whitemove")
        if self.stoneChooseFlag then
            -- print("self.stoneChooseFlag true")
            -- dont check twice or you will freeze
            return
        end
        if BoardSquare:checkForAdvancementStoneChoice(self, rn, ln, top) then
            if top.stoneState == EMPTYSTONESTATE then
                printBSInfo("settig stone to choice",self)
                clearAdvanceStoneFlags()            
                self.stoneChooseFlag = true
                chooseStoneAdvanceState = true
                boardChangedState=true
                table.insert(advanceStonesTable, self)           
                if theSettings.gameSoundOn then
                    -- sound(SOUND_POWERUP, 12740)
                    makeStoneChoiceSound()
                end
                return
            end
        end
        if selfState == WHITESTONESTATE then
            -- print("selfState is whitestone")
            if rn.stoneState == WHITESTONESTATE and ln.stoneState == WHITESTONESTATE then
                -- print("check for white advance")
                -- need to advance to top neighbor if empty and legal
                self.advancingStoneState=WHITESTONESTATE
                if top.stoneState == EMPTYSTONESTATE then
                    if (BoardSquare:checkForHostileCapture(WHITESTONESTATE, top.rightNeighbor, top.leftNeighbor)) then
                        self.stoneState = EMPTYSTONESTATE
                        top.stoneState = WHITESTONESTATE
                        self.advanceStoneFlag=true
                        top.advanceStoneFlag=true
                        currentMove:addAdvance(self, top)
                        boardChangedState = true
                    elseif BoardSquare:legalMove(WHITESTONESTATE, top.rightNeighbor, top.leftNeighbor)  then
                        self.stoneState = EMPTYSTONESTATE
                        top.stoneState = WHITESTONESTATE
                        currentMove:addAdvance(self, top)
                        self.advanceStoneFlag=true
                        top.advanceStoneFlag=true
                        boardChangedState = true
                    else
                        printBSInfo("not advancing",self)
                    end
                end
            end
        elseif selfState == BLACKSTONESTATE and rn.stoneState == WHITESTONESTATE
        and ln.stoneState == WHITESTONESTATE then
            -- we're captured -- self destruct
            print("black stone captured")
            if isAIWhitePlayerMode() then
                self.justCapturedByAI = true
            end
            self.justCapturedBlack = true
            self.stoneState = EMPTYSTONESTATE
            currentMove:addCapture(self)
            theGameBoard.blackStonesCaptured = 
                    theGameBoard.blackStonesCaptured + 1
            boardChangedState = true
        end
    end
    if theSettings.gameSoundOn and self.advanceStoneFlag then
        -- sound(SOUND_JUMP, 12737)
        makeAdvanceSound()
    end
    if theSettings.gameSoundOn then
        if self.justCapturedBlack or self.justCapturedWhite then
            makeCaptureSound()
        end
    end

    if aiCheck and isAIPlayerMode() then    
        -- print("ai player, check for topstone")
        if theAIPlayer.moveState == moveState then
            if top.stoneState == EMPTYSTONESTATE then
                -- nada
            else
                -- print("Skip ai stone for advance")           
            end
        end
    end

    
    
end

-- if 4 or 5 stones are in a row, you can have a choice of which stone(s) to advance
function BoardSquare:checkForAdvancementStoneChoice(bs, rn, ln, top)
    -- print("checkForAdvancementStoneChoice")
    -- print(moveState)
    -- print(state)
    -- print(
    -- print("checkForAdvancementStoneChoice.  NO bypass")
    

    local choiceCount = 0
    if moveState == BLACKMOVE then
        if state == BLACKSTONESTATE then
            if isAdvancementCandidate(bs, rn, ln, top) then
                print("self is adv candidate")
                choiceCount = choiceCount + 1
            end
        end
        if isAdvancementCandidate(rn, rn.rightNeighbor, rn.leftNeighbor, rn.topNeighbor) then
            -- print("rightNeighbor is adv candidate")
            choiceCount = choiceCount + 1
        end
        if isAdvancementCandidate(ln, ln.rightNeighbor, ln.leftNeighbor, ln.topNeighbor) then
            -- print("left Neighbor is adv candidate")
            choiceCount = choiceCount + 1
        end
    elseif moveState == WHITEMOVE then
        if state == WHITESTONESTATE then
            if isAdvancementCandidate(bs, rn, ln, top) then
                print("self is adv candidate")
                choiceCount = choiceCount + 1
            end
        end
        if isAdvancementCandidate(rn, rn.rightNeighbor, rn.leftNeighbor, rn.topNeighbor) then
            -- print("rightNeighbor is adv candidate")
            choiceCount = choiceCount + 1
        end
        if isAdvancementCandidate(ln, ln.rightNeighbor, ln.leftNeighbor, ln.topNeighbor) then
            -- print("left Neighbor is adv candidate")
            choiceCount = choiceCount + 1
        end
    end
    if choiceCount > 1 then
        -- print ("returning true for choice")
        return true
        -- print("choiceCount > 1, but returning false")
        -- return false
    end
    return false
end

function isAdvancementCandidate(bs, rn, ln, top)
    if top == nil then
        return false -- top level situation
    end
    if (top.stoneState == EMPTYSTONESTATE) then
        if bs.stoneState == rn.stoneState and bs.stoneState == ln.stoneState then
            return true
        end
    end
    -- fall thru is false
    return false
end




function BoardSquare:canHostileCapture(stnState)
    -- empty square, but might be surrounded by enemy
    local rn = self.rightNeighbor
    local ln = self.leftNeighbor
    if stnState == WHITESTONESTATE  then
        if rn.stoneState == BLACKSTONESTATE and ln.stoneState == BLACKSTONESTATE then
            --  check for hostile capture
            if rn.rightNeighbor.stoneState == WHITESTONESTATE or ln.leftNeighbor.stoneState == WHITESTONESTATE then
                -- move is ok cause you capture one of the enemy stones
                    goto keepgoing2
            end
            return false
        end
    elseif stnState == BLACKSTONESTATE then
        if rn.stoneState == WHITESTONESTATE and ln.stoneState == WHITESTONESTATE then
            --  check for hostile capture
            if rn.rightNeighbor.stoneState == BLACKSTONESTATE or ln.leftNeighbor.stoneState == BLACKSTONESTATE then
                -- move is ok cause you capture one of the enemy stones
                goto keepgoing2
            end
            return false
        end
    end
    ::keepgoing2::
    -- fall thru its ok to play
    return true
    
end

function BoardSquare:isPlayableSquare(stnState)
    if (self.stoneState == EMPTYSTONESTATE and self.level == currentPlayLevel) then
        goto keepgoing
    else
        return false
    end
    ::keepgoing::
    if stnState == WHITESTONESTATE and self.justCapturedWhite then
        return false
    elseif stnState == BLACKSTONESTATE and self.justCapturedBlack then
        return false
    end
    -- empty square, but might be surrounded by enemy
    local rn = self.rightNeighbor
    local ln = self.leftNeighbor
    if self:canHostileCapture(stnState) then
        goto keepgoing2
    else
        return false
    end
  
    ::keepgoing2::
    -- fall thru its ok to play
    -- printBSInfo("Marked as Available",self)
    return true
end

function xtestTween()
-- Grow in size
    
    c1 = Circle( 0,0,42)
    c2 = Circle(0,0,4)
    t1 = tween( 0.5, c1, {size = 4}, l,
                    function()
                        print("tween 1 finished")
                    end )
    t2 =   tween( 1.5, c2, {size = 42}, l,
                    function() print("tween 2 finished") end )
    -- tmween.sequence( t1, t2)
    
    
    
    testingTween = true
end

function xdrawTween() 
      background(40, 40, 50)
    local x = WIDTH/2
    local y = HEIGHT/2
    local w = 45
    local h = 45
    pushStyle()
    strokeWidth(2)
    stroke(darkGrayColor)    
    fill(redColor)
    rect(x,y,w,h)
    fill(whiteColor)
    x = x + 22
    y = y + 22
    c1.x = x
    c1.y = y
    c2.x= x
    c2.y =y
    -- c1:draw()
    c2:draw()
    -- Utilities:delay(3000)
    
    popStyle()
    
end


--# LogDialog
LogDialog = class()

function LogDialog:init()
    print("LogDialog:init()")
    self.active=false
    self.x=WIDTH/2
    self.y=HEIGHT/2 - 6
    
    self.logReader=TextReader({})
    self.logReader.ftype="COURIER"
    self.logReader.w=720
    self.logReader.h=574
    self.logReader.pageSize=25
    self.logReader.y = self.logReader.y + 30
    self.logReader.hasBorder=false
    self.logReader.hasButtons=true
    self.logReader.hasEnclosingPanel=false
    self.logTextTable = {}
    
    fontSize(24)
    font("ArialRoundedMTBold")
    --[[
    local c1 = ivoryMeshColor
    local c2 = lightestslateblueColor
    local pc1 = lightslateblueColor
    local pc2 = darkslateblueColor
      ]]
    local t="Close"
    local h=50
    local w = 150
    self.closeButton = MeshButton(t,0,0,w,h)
    -- self.closeButton:setColors(c1,c2,pc1,pc2)
    self.closeButton.action = function () self:closeDialog() end
    
    local t="Copy"
    self.copyButton = MeshButton(t,0,0,w,h)
    -- self.copyButton:setColors(c1,c2,pc1,pc2)
    self.copyButton.action = function () self:copyLog() end
    
end

function LogDialog:draw()
    -- Codea does not automatically call this method
    if self.active then
        -- print("LogDialog active")
    else
        return
    end
 pushStyle()
    local x = self.x
    local y = self.y 
    -- textWrapWidth(500)
    -- local w, h = textSize(self.message) 
    local w =  760
    local h = HEIGHT - 120
    local bw = w +15
    local bh = h+15
    local bx = x - bw/2
    local by=y-bh/2
    local rx = x- w/2
    local ry = y-h/2
    y = y + 40
    
    fill(slategrayColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    font("HelveticaNeue-bold")
    fontSize(24)
    
    self.logReader:draw()
    y = y - HEIGHT/2 + 35
    x = x - 166
    self.closeButton.x=x
    self.closeButton.y=y
    self.closeButton:draw()
    
    x = x +200
    self.copyButton.x=x
    self.copyButton.y=y
    self.copyButton:draw()
    -- only draws when active

end

function LogDialog:touched(touch)
    -- Codea does not automatically call this method
    if self.active then
        -- print("LogDialog active for touch")
    else
        return
    end
    if self.logReader:touched(touch) then
        return
    end
    self.closeButton:touched(touch)   
    self.copyButton:touched(touch)   
end

function LogDialog:createLogText()
    if next(theMoveTable) == nil then
   -- theMoveTable is emptyg
        self.logText = "No moves accumulated, cannot create log"      
    end
    -- store each line in a table, then use table.concat with newline to create log tex
    self.logTextTable = {}
    local theLimit  = # theMoveTable    --theMoveTableble is stack, so we iterate from end
    -- print ("BEGIN: createLogText")
    -- 
    local blackMv, whiteMv, whiteBs, blackBs = nil
    local str,hdrStr, blackStr, whiteStr = ""
    -- each stone has a line for its initial placemwnt
    -- then a line for each capture/advance activity
    local blackStrTable = {}
    local whiteStrTable = {}
    -- add log table headers
    local tmStr = os.date("_%G_%m%d_%H%M")
    -- we add ".zlog" extension when saved, to filter for list
    self.logSaveName= string.format("zlog%s", tmStr)
    -- print(self.logSaveName)
    str="\tZiqqurat Game Log: "..os.date()
    table.insert(self.logTextTable, str)
    --[[
    local bpName = theSettings.blackPlayerName
    local wpName = theSettings.whitePlayerName
    if isAIBlackPlayerMode() then
        bpName = iPadAiName
    elseif isAIWhitePlayerMode() then
        wpName = iPadAiName
    end
    str=string.format("\t\tBlack:%s   vs   White:%s", bpName, wpName)
    table.insert(self.logTextTable, str)
    str=""
      ]]
    table.insert(self.logTextTable, str)
    str="\t     BLACK          WHITE"
    table.insert(self.logTextTable, str)
    str="\t     -----          -----"
    table.insert(self.logTextTable, str)
    
    -- build up the string tables
    for i=theLimit,1,-1 do
        
        local mvObj=theMoveTable[i]
        local mvType=mvObj.moveType
        local bs = mvObj.bs
        
        --[[
        if bs == nil then
            -- print("Move board square is nil")
            bs = BoardSquare(8,0,0,0)
        end
          ]]
        -- str = string.format("Move: %d %s:%d,%d ", mvObj.turnNumber, moveInitials[mvType],bs.level, bs.index)
        -- ""print(str)
    
        if mvType == BLACKMOVE then
            -- print("setting up Black")
            blackStrTable = {}
            blackMv = mvObj
            blackBs = bs
            
            if blackMv.pass then
                blackStr = string.format("B:Pass                           ")
            elseif blackMv.handicap then
                blackStr = string.format("B:Handicap                           ")
            elseif blackBs == nil then
                blackStr = string.format("B:nil                            ")
            else
                blackStr = string.format("B:%d,%d                  ",  blackBs.level, blackBs.index)
            end

            -- append to table
            table.insert(blackStrTable, blackStr)
            -- if last move was by black we want to check it
             if i==1 then
                whiteStr = ""
                whiteMv = nil
                whiteStrTable = {}
                goto activitylogic
            end
            goto zcontinue
        elseif mvType == WHITEMOVE then
            -- print("setting up white")
            whiteStrTable = {}
            whiteMv = mvObj
            whiteBs = bs
            -- if black has last move we use level 8 to signal yhat white did not play
            
            if whiteMv.pass then
                whiteStr = string.format("W:Pass    ")
            elseif whiteBs == nil then
                whiteStr = string.format("W:nil         ")
            else
                whiteStr = string.format("W:%d,%d    ",  whiteBs.level, whiteBs.index)
            end
            -- append to table
             table.insert(whiteStrTable, whiteStr)
        else
            -- print("no action for mvType %d",mvType)
        end
        
        
        -- print("Move:"..mvObj.turnNumber.." "..moveInitials[mvType
        -- print(whiteStrTable)
        -- print(blackStrTable)
        ::activitylogic::
        if blackMv == nil then
            goto whiteactivity
        end
        actTable = blackMv.activityTable
        for i=1, # actTable do
            str=""
            mvAct = actTable[i]
            if mvAct.activityType == CAPTURE_ACTIVITY then
                bs = mvAct.boardSq
                if bs then
                    str = string.format("     X:%d,%d                ",bs.level, bs.index)
                    table.insert(blackStrTable, str)
                end
            elseif mvAct.activityType == ADVANCE_ACTIVITY then
                if fromBs and toBs then
                    fromBs = mvAct.boardSq
                    toBs = mvAct.destBoardSq
                    str = string.format("     A:%d,%d-->%d,%d      ",
                    fromBs.level, fromBs.index, toBs.level, toBs.index)
                    -- print("inserting ADVANCE into blackStrTable: "..str)
                    table.insert(blackStrTable, str)
                end
            elseif mvAct.activityType == HANDICAP_ACTIVITY then
                bs = mvAct.boardSq
                if bs then
                    str = string.format("     H:%d,%d                ",bs.level, bs.index)
                    table.insert(blackStrTable, str)
                end
            end
        end
        
        
        ::whiteactivity::
        if whiteMv == nil then
            goto zprint
        end
        actTable = whiteMv.activityTable
        for i=1, # actTable do
            str="" 
            mvAct = actTable[i]
            if mvAct.activityType == CAPTURE_ACTIVITY then
                bs = mvAct.boardSq
                if bs then
                    str = string.format("  X:%d,%d                ",bs.level, bs.index)
                    table.insert(whiteStrTable, str)
                end
            elseif mvAct.activityType == ADVANCE_ACTIVITY then
                fromBs = mvAct.boardSq
                toBs = mvAct.destBoardSq
                if fromBs and toBs then
                    str = string.format("  A:%d,%d-->%d,%d      ",
                    fromBs.level, fromBs.index, toBs.level, toBs.index)
                    -- print("inserting ADVANCE into whiteStrTable: "..str)
                    table.insert(whiteStrTable, str)
                end
            end
            ::zcontine::  
        end
        
        
        
        ::zprint::
        blSize = # blackStrTable
        wtSize = # whiteStrTable
        maxSize = 0
    
        if blSize >= wtSize then
            maxSize = blSize
        else
            maxSize = wtSize
        end
        --[[
        print("string tbl dumps")
        for i = 1, blSize do
            print(blackStrTable[i])
        end
        for i = 1, wtSize do
            print(whiteStrTable[i])
        end
          ]]
        for i=1, maxSize do
            if i == 1 then
                hdrStr= string.format("%d.    ", blackMv.turnNumber)
                hdrStr=string.sub(hdrStr,1,5)
                if blSize >= 1 then
                    blackStr = blackStrTable[i]
                else
                    blackStr = "                                         "
                end
                if wtSize >= 1 then
                    whiteStr = whiteStrTable[i]
                else
                    whiteStr = ""
                end
                blackStr=string.sub(blackStr,1,15) 
                str = string.format("%s%s%s", hdrStr, blackStr, whiteStr)
            else  -- i > 1
                if blSize >= i then
                    blackStr = blackStrTable[i]
                else
                    blackStr = "                                         "
                end
                if wtSize >= i then
                    whiteStr = whiteStrTable[i]
                else
                    whiteStr = ""
                end
                blackStr=string.sub(blackStr,1,18) 
                str = string.format("%s%s", blackStr, whiteStr)
            end
            -- print(str)
            str=string.format("\t%s", str)
            table.insert(self.logTextTable, str)
        end
        
        -- print(str)
        ::zcontinue::
        -- blackStrTablee = {}
        -- whiteStrTable = {}
        blacksStr = ""
        whiteStr = ""
        
    end
    -- add some blank lines to aid scrolling
    for i=1, 3 do
        table.insert(self.logTextTable, "")
    end
    
    str = "\tGame Board State"
    table.insert(self.logTextTable, str)
    str = ""
    table.insert(self.logTextTable, str)
    str=string.format("\tCaptured Black Stones:%d    Captured White Stones:%d",theGameBoard.blackStonesCaptured, theGameBoard.whiteStonesCaptured)
    table.insert(self.logTextTable, str)
    str = ""
    table.insert(self.logTextTable, str)
    str = "\t               1         2         3         4 "
    table.insert(self.logTextTable, str)
    str = "\tLEVEL 123456789012345678901234567890123456789012345678 "
    table.insert(self.logTextTable, str)
    -- str = "\t----- ------------------------------------------------"'
    -- table.insert(self.logTextTable, str)
    for i=1, 7 do
        local t = theGameBoard.levelIndexTable[i]
        str = string.format("\t  %d   ", i)
        for j = 1, # t do
            bs = t[j]
           local  state = "-"
            if bs.stoneState== BLACKSTONESTATE then
                state="B"
            elseif bs.stoneState == WHITESTONESTATE then
                state ="W"
            end
            str = string.format("%s%s", str,state)
        end 
    table.insert(self.logTextTable, str)
    end
    str=""
    table.insert(self.logTextTable, str)
    str = string.format("\t\t%s v. %s\tCopyright %s",gameName,gameVersion,COPYRIGHTSTR)
    table.insert(self.logTextTable, str)
    --[[
    str = "\t"
    table.insert(self.logTextTable, str)
    str = "\t"
    table.insert(self.logTextTable, str)
    str = "\t"
    table.insert(self.logTextTable, str)
    str = "\t"
    table.insert(self.logTextTable, str)
      ]]
    for i=1, 5 do
        table.insert(self.logTextTable, "")
    end
    self.logReader.textTable=self.logTextTable
    
    --[[
    -- self.numLogLines = #self.logTextTable
    self.logText = table.concat(self.logTextTable, "\n")
    -- print("************LOG TEXT***********")
    -- print(self.logText)
    self:initLogScroll()
      ]]
end


function LogDialog:xxxcreateLogReaderText(turnTable)
    print("LogDialog:createLogReaderText(turnTable)")
    local logTextTable={}
    
    -- declare all the temps as local
    local turn= nil
    local move=nil
    local play = nil
    local tNum=0
    local blackStr=""
    local whiteStr=""
    local blackMoveStrTable={}
    local whiteMoveStrTable={}
    -- the turn table is a stack, so turn 1 is at the bottom
    local limit = #turnTable
    local size = 0
    local indent="    "
    local s=string.format("%s Game Log; %s",GAMENAME,os.date() )  
    s=indent..s
    table.insert(logTextTable, s)
    s=" "
    table.insert(logTextTable, s)
    s="Game Pieces:  P=Placed  C=Created  X=Captured"
    s=indent..s
    table.insert(logTextTable, s)
    table.insert(logTextTable, " ")
    -- local s="TURN  BLACK                   WHITE"
    local s="BLACK                    WHITE"
    s=indent..s
    table.insert(logTextTable, s)
    -- local s="====  =====                   ====="
    local s="====================     ===================="
    local pad="                                   "

    s=indent..s
    table.insert(logTextTable, s)
    for i = limit, 1, -1 do
        turn = turnTable[i]
        if turn == nil then
            goto zcontinue
        end
        tNum=turn.turnNumber
        move=turn.blackMove
        if move == nil then 
            goto zcontinue
        end
        blackMoveStrTable=self:getMoveStrTable(move)
        move=turn.whiteMove
        if move == nil then 
            goto zcontinue
        end
        whiteMoveStrTable=self:getMoveStrTable(move)
        sz=#blackMoveStrTable
        if #whiteMoveStrTable > sz then
            sz=#whiteMoveStrTable
        end
        for j=1, sz do
            blackStr=blackMoveStrTable[j]
            whiteStr=whiteMoveStrTable[j]
            if blackStr == nil then
                blackStr="                                  "
            end
            if whiteStr== nil then
                whiteStr=""
            end
            blackStr=indent..blackStr..pad
            -- truncate blackstr only
            blackStr=string.sub(blackStr,1,29)
            s=string.format("%s%s",blackStr,whiteStr)
            table.insert(logTextTable, s)
        end
        
        ::zcontinue::
    end
    table.insert(logTextTable, " ")
    table.insert(logTextTable, " ")
    s=string.format("BLACK: Captured White Stones %d   Total Game Points %d",theGameBoard.blackCapturedPrisoners,999)
    table.insert(logTextTable, s)
    s=string.format("WHITE: Captured Black Stones %d   Total Game Points %d",theGameBoard.whiteCapturedPrisoners,999)
    table.insert(logTextTable, s)
    table.insert(logTextTable, " ")
    table.insert(logTextTable, "  Game Board State:")
    s="                          1"
    if theGameBoard.diam == GAMEBOARD_DIAMETER_23 then
        s="                          1                   2"
    end

    table.insert(logTextTable, s)
    s="  ROW   1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9"
    if theGameBoard.diam == GAMEBOARD_DIAMETER_23 then
        s="  ROW   1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3"
    end
    table.insert(logTextTable, s)
    local bpt = theGameBoard.boardPointTable
   
    for i=# bpt,1,-1 do
        -- print("i:"..i)
        local rowTable = bpt[i]
        local rowAlpha=AlphaRowTable[i]
        s="   "..rowAlpha.."   "
        for j=1, #rowTable do
            local bp=rowTable[j]
            stInitial=bpStateInitial[bp.state]
            s=s.." "..stInitial         
        end
        table.insert(logTextTable, s)
    end  
    table.insert(logTextTable, " ")
    s=string.format("  %s v %s  Copyright %s",
        GAMENAME,GAMEVERSION,COPYRIGHTSTR)
    table.insert(logTextTable, s)
    self.logReader.textTable=logTextTable
end

function LogDialog:getMoveStrTable(move)
    print("LogDialog:getMoveStrTable(move)")
    print(move)
    local moveStrTable={}
    if move == nil then
        return moveStrTable
    end
    local playTable=move.playTable
    local moveTypeStr=moveTypeInitial[move.moveType]
    local tNum=move.turnNumber
    local limit = #playTable
    local s=""
    for i= limit, 1, -1 do
        local play=playTable[i]
        local playType=play.playType
        local playNum=play.playNumber
        local playNumAlpha=AlphaPlayNumberTable[playNum]
        local playTypeStr=playtypeInitial[playType]
        local state=play.state
        local stateStr=bpStateText[state]
        local gamePiece=gamePieceColorStr[state]
        local bp=play.boardPoint
        local row=bp.row
        local rowAlpha=AlphaRowTable[row]
        local index=bp.index
        if i==limit then
            s=string.format("%s%-2d %s:%s,%-2d  %s-%s",
            moveTypeStr,tNum,playNumAlpha,rowAlpha,index,playTypeStr,gamePiece) 
        else
            s=string.format("    %s:%s,%-2d  %s-%s",
            playNumAlpha,rowAlpha,index,playTypeStr,gamePiece)
        end
        table.insert(moveStrTable,s)
    end
    return moveStrTable
end

function LogDialog:closeDialog()
        self.active=false   
end

function LogDialog:copyLog()
    local tt=self.logReader.textTable
    local logStr=table.concat(tt,"\n")
    pasteboard.copy(logStr)
    theGameBoard.logCopiedMP.active=true
end


--# SelectHandicapDialog
SelectHandicapDialog = class()

function SelectHandicapDialog:init()
    print("SelectHandicapDialog init")
    self.x=WIDTH/2
    self.y=HEIGHT/2
    self.active=false
    self.selectArray={}
    self:makeArray()
end

function SelectHandicapDialog:makeArray()
    self.selectArray={}
    local hTable = theSettings.handicapTable
    fontSize(24)
    font("HelveticaNeue-Bold")
    for i=1, #hTable do
        local n = hTable[i]
        local b = Button(n)
        b.action=function() end
        b.minWidth=80
        table.insert(self.selectArray,1,b)
    end
    --[[
    local ar=self.selectArray
    print("select array")
    for i = 1, #ar do
        print(ar[i])
    end
      ]]
    
end

function SelectHandicapDialog:draw()
    -- Codea does not automatically call this method
    if not self.active then
        -- caller has to set active to true to engage functionality
        return
    end
    pushStyle()
    local x = self.x
    local y = self.y 
    -- textWrapWidth(500)
    -- local w, h = textSize(self.message)
    w =  100
    h = 260
    bw = w +15
    bh = h+15
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2
    ry = y-h/2
    y = y + 40 
    fill(slategrayColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    y = y - 144
    x = x 
    local ar=self.selectArray
    for i = 1, #ar do
        b=ar[i]
        b.pos=vec2(x,y)
        y = y + 30
        b:draw()
    end
    
end

function SelectHandicapDialog:touched(touch)
    -- Codea does not automatically call this method
    local ar=self.selectArray
    for i = 1, #ar do
        b=ar[i]
        if b:touched(touch) then
            
            theSettings.currentHandicap=b.displayName

            --[[
            local s=string.format("SelectHandicap button %d touched  currentHandicap:%s", 
                    i,theSettings.currentHandicap)
            print(s)
              ]]
            self.active=false
            return true
        end
    end
    return false

end

--# Defaults
Defaults = class()

-- holds the default settins that user can alter
-- used by reset button and to first initialize

function Defaults:init()
    -- you can accept and set parameters here
    -- self.blackPlayerName = "Player 1"
    -- self.whitePlayerName = "Player 2"
    self.gameBoardSize=MEDIUM_GAMEBOARD_SIZE
    self.playerMode = PLAYERVSWHITEAI
    self.showBoardIndexNumbers=false
    self.highlightCurrentLevel=true
    self.showLastMove=true
    self.showCapturingStone=true
    self.currentHandicap="None"
    self.saveRestoreCurrentGame=true
    self.gameSoundOn=true
    self.playSpeed=PLAYSPEED_NORMAL

end

function Defaults:draw()
    -- Codea does not automatically call this method
end

function Defaults:touched(touch)
    -- Codea does not automatically call this method
end

--# SettingsDialog
SettingsDialog = class()

function SettingsDialog:init(x)
    -- you can accept and set parameters here
    print("SettingsDialog: init()")
    theSettings:loadSettings()
    
    -- textbox accepting keyboard input, if any
    textBoxAcceptingInput = nil
    settingsChangeFlag = false
    self.firstTimeRefresh=true
    -- self.drawCount=0
    self.drawCount = 0
    
    self.x=WIDTH/2
    self.y=HEIGHT/2 + 15
    self.active=false
    
    self.largeRB = RadioButton("Large")
    self.mediumRB = RadioButton("Medium")
    self.smallRB = RadioButton("Small")
    self.customRB = RadioButton("Custom")
    
    local key=theSettings.gameBoardSize
    -- print(key)""
    self.selectGameBoardSizeDialog= SelectDialog(theSettings.gameBoardSizeTable, key, theSettings.gameBoardSizeDisplayTable)
    self.selectGameBoardSizeDialog.action = function(selected) self:setGameBoardSize(selected) end
    self.selectGameBoardSizeDialog.minWidth=80
    self.selectGameBoardSizeDialog.borderColor=slategrayColor   
    self.gameBoardSizeSettingButton=Button(theSettings.gameBoardSizeDisplayTable[key])
    self.gameBoardSizeSettingButton.action = function() self:selectGameBoardSize() end
    self.gameBoardSizeSettingButton.minWidth=80
    self.gameBoardSizeSettingButton.border=true
    
    local key=theSettings.playSpeed
    print("setting up playSpeed")
    print(key)
    print(theSettings.playSpeedDisplayTable[key])
    self.selectPlaySpeedDialog= SelectDialog(theSettings.playSpeedTable, key, theSettings.playSpeedDisplayTable)
    self.selectPlaySpeedDialog.action = function(selected) self:setPlaySpeed(selected) end
    self.selectPlaySpeedDialog.minWidth=80
    self.selectPlaySpeedDialog.borderColor=slategrayColor       
    
    self.playSpeedSettingButton=Button(theSettings.playSpeedDisplayTable[key])
    self.playSpeedSettingButton.action = function() self:selectPlaySpeed() end
    self.playSpeedSettingButton.minWidth=80
    self.playSpeedSettingButton.border=true
    
    
    self.indexNumSTC= SwitchToggleControl(0,0,false)
    self.indexNumSTC.onChange= function(switchOn) self:setShowBoardIndexNumbersSetting(switchOn) end
    
    self.highlightLevelSTC = SwitchToggleControl(0,0,true)
    self.highlightLevelSTC.onChange = function(switchOn) self:setHiglightLevelSetting(switchOn) end
    
    self.aiLastMoveSTC= SwitchToggleControl(0,0,true)
    self.aiLastMoveSTC.onChange= function(switchOn) self:setshowLastMoveSetting(switchOn) end
    
    self.aiCapturesSTC= SwitchToggleControl(0,0,true)
    self.aiCapturesSTC.onChange= function(switchOn) self:setshowCapturingStone(switchOn) end
    
    self.saveRestoreCurrentGameSTC= SwitchToggleControl(0,0,true)
    self.saveRestoreCurrentGameSTC.onChange= function(switchOn)  self:setSaveRestoreCurrentGame(switchOn) end
    
    self.gameSoundOnSTC=SwitchToggleControl(0,0,true)
    self.gameSoundOnSTC.onChange = function(switchOn) self:setGameSoundOn(switchOn) end
    
    
    -- Buttons at bottom
    local t="Close"
    local w= textSize(t)
    local h=50
    w = w + 40
    self.closeButton = MeshButton(t,0,0,w,h)
    self.closeButton.action = function () self.active = false end 
    self.confirmResetToDefaultsMP = MessagePanel("Warning! Settings will be reset to default settings. Is this OK?")
    self.confirmResetToDefaultsMP.action = function() self:setSettingsToDefaults() end
    
    self:refreshSettings()
end

function SettingsDialog:draw()
    -- Codea does not automatically call this method
    if self.active then
        -- goood to go
    else
        return
    end
    self.drawCount = self.drawCount + 1
    if self.drawCount == 1 then
        print("SettingsDialog:draw()")
    else
        
    end
    
    pushStyle()
    local spacer=30
    local x,y,w,h = 0
    local x = self.x
    local y = self.y
    -- textWrapWidth(500)
    -- local w, h = textSize(self.message)
    local w =  680
    local h = HEIGHT - 104
    local bw = w +15
    local bh = h+15
    local bx = x - bw/2
    local by=y-bh/2
    local rx = x- w/2
    local ry = y-h/2
    y = y + 290
    
    fill(slategrayColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    font("HelveticaNeue-bold")
    fontSize(24)
    
    
    
    local imgX = x
    local imgY = y
    w = 200 -- 8/3 aspect or sone such
    h=75
    -- sprite("Documents:ziggurat _image3",imgX,imgY,w, h)
    -- sprite("Documents:Ziggurat_image1",imgX,imgY,w,h)
    
    
    font("HelveticaNeue-BoldItalic")
    fontSize(48)
    -- fill(whiteColor)
    x = x - 84
    y = y - 25
    fill(blackColor)
    textMode(CORNER)
    text("Settings", x, y)
    
    -- fill(slategrayColor)
    x = x - 220
    
    x = x + 20
    
    
    -- roundRect(x,y,rectW, 420, 20)
    -- y = y + 380
    textMode(CORNER)
    -- y = y +132
    y = y - 50
    x = x +  65
    fill(blackColor)
    font("HelveticaNeue-BOLD")
    fontSize(22)
    text("Game Board Size:" ,x, y)
    local textX = x
    x = x + 244
    y = y + 13
    self.gameBoardSizeSettingButton.pos=vec2(x,y)
    self.gameBoardSizeSettingButton:draw()
    self.selectGameBoardSizeDialog.x=x+2
    self.selectGameBoardSizeDialog.y=y
    
    
    y = y -63
    x=textX
    text("Game Play Speed:" ,x, y)
    x = x + 244
    y = y + 13
    self.playSpeedSettingButton.pos=vec2(x,y)
    self.playSpeedSettingButton:draw()
    self.selectPlaySpeedDialog.x=x+2
    self.selectPlaySpeedDialog.y=y
    
    
    
    x=textX
    y = y -63
    fontSize(22)
    fill(blackColor)
    textMode(CORNER)
    
    local switchX = x + 450
    text("Show index # on board",textX,y)
    y = y + 11
    self.indexNumSTC.x=switchX
    self.indexNumSTC.y=y
    self.indexNumSTC:draw()
    
    y = y - 50
    fill(darkGrayColor)
    textMode(CORNER)
    text("Highlight current play level",textX,y)
    y = y + 11
    self.highlightLevelSTC.x=switchX
    self.highlightLevelSTC.y=y
    self.highlightLevelSTC:draw()
    
    y = y - 50
    fill(darkGrayColor)
    textMode(CORNER)
    text("Show last move",textX,y)
    y = y + 11
    self.aiLastMoveSTC.x=switchX
    self.aiLastMoveSTC.y=y
    self.aiLastMoveSTC:draw()
    
    y = y - 50
    fill(darkGrayColor)
    textMode(CORNER)
    text("Show capturing stone",textX,y)
    y = y + 11
    self.aiCapturesSTC.x=switchX
    self.aiCapturesSTC.y=y
    self.aiCapturesSTC:draw()
    
    y = y - 50
    fill(darkGrayColor)
    textMode(CORNER)
    text("Set Game Sound On",textX,y)
    y = y + 11
    self.gameSoundOnSTC.x=switchX
    self.gameSoundOnSTC.y=y
    self.gameSoundOnSTC:draw()
    
    y = y - 50
    fill(darkGrayColor)
    textMode(CORNER)
    text("Save and restore existing",textX,y)
    y = y + 11
    y = y - 30
    text("game between sessions",textX,y)
    y = y + 11
    self.saveRestoreCurrentGameSTC.x=switchX
    self.saveRestoreCurrentGameSTC.y=y
    self.saveRestoreCurrentGameSTC:draw()
    
    y = y - 200
    x = WIDTH/2 - 50
    self.closeButton.x=x
    self.closeButton.y=y
    self.closeButton:draw()
    
    
    self.selectGameBoardSizeDialog:draw()
    self.selectPlaySpeedDialog:draw()
    
    popStyle()
    
end

function SettingsDialog:touched(touch)
    -- Codea does not automatically call this method
    
    if self.selectPlaySpeedDialog.active then
        if self.selectPlaySpeedDialog:touched(touch) then
            print("selectPlaySpeedDialog active and touched")
            self.selectPlaySpeedDialog.selected=theSettings.playSpeed
            return
        end
        return
    end
    self.playSpeedSettingButton:touched(touch)
    
    if self.selectGameBoardSizeDialog.active then
        if self.selectGameBoardSizeDialog:touched(touch) then
            print("selectGameBoardSizeDialog active and touched")
            self.selectGameBoardSizeDialog.selected=theSettings.gameBoardSize
            return
        end
        return
    end
    self.gameBoardSizeSettingButton:touched(touch)
    
    
    if self.selectPlaySpeedDialog.active then
        if self.selectGameBoardSizeDialog:touched(touch) then
            print("handicapDialog active and touched")
            self.selectGameBoardSizeDialog.selected=theSettings.gameBoardSize
        end
        return
    end
    self.gameBoardSizeSettingButton:touched(touch)
    
    
    if self.indexNumSTC:touched(touch) then
        settingsChangeFlag=true
    elseif self.highlightLevelSTC:touched(touch) then
        settingsChangeFlag=true
    elseif self.aiLastMoveSTC:touched(touch) then
        settingsChangeFlag=true
    elseif self.aiCapturesSTC:touched(touch) then
        settingsChangeFlag=true
    elseif self.saveRestoreCurrentGameSTC:touched(touch) then
        settingsChangeFlag=true
    elseif self.gameSoundOnSTC:touched(touch) then
        settingsChangeFlag=true
    end
    
    self.closeButton:touched(touch)
    self:refreshSettings()
    theSettings:saveSettings()
    settingsChangeFlag=false
end
-- Hack, Hack

function SettingsDialog:refreshSettings()
    
    local s=string.format("SettingsDialog - showIdx:%s showLastMove:%s  showCapt:%s soundOn:%s",
    theSettings.showBoardIndexNumbers,
    theSettings.showLastMove,
    theSettings.showCapturingStone,
    theSettings.gameSoundOn
    )
    print(s)
    
    self:setGameBoardSize(theSettings.gameBoardSize)
    self:setPlaySpeed(theSettings.playSpeed)
    self.indexNumSTC.switchOn = theSettings.showBoardIndexNumbers
    self.highlightLevelSTC.switchOn = theSettings.highlightCurrentLevel
    self.aiLastMoveSTC.switchOn = theSettings.showLastMove
    self.aiCapturesSTC.switchOn = theSettings.showCapturingStone
    self.saveRestoreCurrentGameSTC.switchOn = theSettings.saveRestoreCurrentGame
    self.gameSoundOnSTC.switchOn = theSettings.gameSoundOn
    if self.firstTimeRefresh then
        self.firstTimeRefresh = false
    else
        theMenuPanel:refreshSettings()
    end
end

function SettingsDialog:selectGameBoardSize()
    print("SettingsDialog:selectGameBoardSize()")
    self.selectGameBoardSizeDialog.active=true
end

function SettingsDialog:setGameBoardSize(selected)
    print("MenuPanel:setPlayerMode(selected)")
    print(selected)
    theSettings.gameBoardSize=selected
    local display=theSettings.gameBoardSizeDisplayTable[selected]
    self.gameBoardSizeSettingButton.displayName=display
    -- self:refreshSettings()
end

function SettingsDialog:selectPlaySpeed()
    print("SettingsDialog:selectPlaySpeed()")
    self.selectPlaySpeedDialog.active=true
end

function SettingsDialog:setPlaySpeed(selected)
    print("SettingsDialog:setPlaySpeed(selected)")
    print(selected)
    theSettings.playSpeed=selected
    local display=theSettings.playSpeedDisplayTable[selected]
    self.playSpeedSettingButton.displayName=display
    -- self:refreshSettings()
end


function SettingsDialog:setGameSoundOn(switchOn)
    print("setGameSoundOn- switchon")
    print(switchOn)
    theSettings.gameSoundOn = switchOn
end


function  SettingsDialog:setShowBoardIndexNumbersSetting(switchOn)
    theSettings.showBoardIndexNumbers = switchOn
end

function SettingsDialog:setHiglightLevelSetting(switchOn)
    theSettings.highlightCurrentLevel = switchOn
end

function SettingsDialog:setshowLastMoveSetting(switchOn)
    theSettings.showLastMove = switchOn
end

function SettingsDialog:setshowCapturingStone (switchOn)
    theSettings.showCapturingStone = switchOn
end

function  SettingsDialog:setSaveRestoreCurrentGame(switchOn)
    theSettings.saveRestoreCurrentGame = switchOn
end

















--# Settings 
Settings  = class()

--[[
self.blackPlayerName = "Player 1"
    self.whitePlayerName = "Player 2"
    self.gameBoardSize=MEDIUM_GAMEBOARD_SIZE
    self.playerMode = 
  ]]
function Settings:init()
    -- you can accept and set parameters here
    print("Settings:init()")
    self.defaults = Defaults()
    self:setDefaults()
    -- self.blackPlayerNameKey="blackPlayerName"
    -- self.whitePlayerNameKey = "whitePlayerName"
    self.gameBoardSizeKey="gameBoardSize"
    self.playerModeKey = "playerMode" 
    self.currentHandicapKey = "currentHandicap" 
    self.playSpeedKey = "playSpeed" 
    self.showBoardIndexNumbersKey="showBoardIndexNumbers"
    self.highlightCurrentLevelKey="highlightCurrentLevel"
    self.showLastMoveKey="showLastMove"
    self.showCapturingStoneKey="showCapturingStone"
    self.saveRestoreCurrentGameKey="saveRestoreCurrentGame"
    self.currentGameKey="game in progress"   
    self.gameSoundOnKey="gameSoundOn"
    -- black has 1st move so lowest handicap is 2
    -- start with middle, then corners  
    
    
    self.handicapTable =
    {
    "None",
    2,
    3,
    4,
    5,
    6,
    7,
    8
    }

    
    self.playerModeTable ={
    PLAYERVSWHITEAI,
    PLAYERVSBLACKAI,
    BLACKAIVSWHITEAI,
    PLAYERVSPLAYERMODE,
    MANUALPLAYMODE
    }
    self.playerModeDisplayTable= {
    "Player vs White AI",
    "Player vs Black AI",
    "Black AI vs White AI",
    "Player vs Player",
    "Manual Play Mode"
    }

    self.gameBoardSizeTable = {
    SMALL_GAMEBOARD_SIZE,
    MEDIUM_GAMEBOARD_SIZE,
    LARGE_GAMEBOARD_SIZE,
    }
    self.gameBoardSizeDisplayTable = {
    "Small",
    "Medium",
    "Large",
    }
    -- self.currentHandicap=self.handicapTable[1]
    
    self.playSpeedTable = {
    PLAYSPEED_FAST,
    PLAYSPEED_NORMAL,
    PLAYSPEED_SLOW,
    PLAYSPEED_TURGID,
    }
    self.playSpeedDisplayTable ={
    "Fast",
    "Normal",
    "Slow",
    "Turgid"
    }
    
    
end

function Settings:setDefaults()
    -- you can accept and set parameters here
    -- print("Settings:init()")
    self.defaults = Defaults()
    local df = self.defaults
    -- self.blackPlayerName = df.blackPlayerName
    -- self.whitePlayerName = df.whitePlayerName
    self.gameBoardSize= df.gameBoardSize
    self.playerMode = df.playerMode
    self.showBoardIndexNumbers=df.showBoardIndexNumbers
    self.highlightCurrentLevel=df.highlightCurrentLevel
    self.showLastMove=df.showLastMove
    self.showCapturingStone=df.showCapturingStone
    self.currentHandicap=df.currentHandicap
    self.saveRestoreCurrentGame=df.saveRestoreCurrentGame
    self.gameSoundOn=df.gameSoundOn
    self.playSpeed=df.playSpeed
end

function Settings:resetToDefaults()
    self:setDefaults()
    self:saveSettings()
end

function Settings:saveSettings()
    -- print("saveSettings")
    -- saveLocalData(self.blackPlayerNameKey, self.blackPlayerName)
    -- saveLocalData(self.whitePlayerNameKey, self.whitePlayerName)
    saveLocalData(self.gameBoardSizeKey, self.gameBoardSize)
    saveLocalData(self.playerModeKey, self.playerMode)  
    -- if number, save as int
    local hc=self.currentHandicap
    
    saveLocalData(self.currentHandicapKey, self.currentHandicap)        
    saveLocalData(self.showBoardIndexNumbersKey, self.showBoardIndexNumbers)
    saveLocalData(self.highlightCurrentLevelKey, self.highlightCurrentLevel)
    saveLocalData(self.showLastMoveKey, self.showLastMove)
    saveLocalData(self.showCapturingStoneKey, self.showCapturingStone)
    saveLocalData(self.saveRestoreCurrentGameKey, self.saveRestoreCurrentGame)  
    saveLocalData(self.gameSoundOnKey, self.gameSoundOn)  
    saveLocalData(self.playSpeedKey, self.playSpeed)  
    
    -- local s =string.format("showBoardIndexNumbers: %s  showLastMove: %s  showCapturingStone: %s", self.showBoardIndexNumbers, self.showLastMove, self.showCapturingStone)
end

function Settings:loadSettings()
    -- print("loadSettings")
    --[[
    self.blackPlayerName = readLocalData(self.blackPlayerNameKey, self.blackPlayerName)
    self.whitePlayerName = readLocalData(self.whitePlayerNameKey, self.whitePlayerName)
      ]]
    local df = self.defaults
    self.gameBoardSize = readLocalData(self.gameBoardSizeKey, self.gameBoardSize, df.gameBoardSize)
    self.playerMode = readLocalData(self.playerModeKey, df.playerMode)  
    -- displays as float w/oncoercion to int
    local hc = readLocalData(self.currentHandicapKey, df.currentHandicap)  
    if hc ~= df.currentHandicap then
        hc = string.format("%d",hc)
    end
    self.currentHandicap = hc

    self.showBoardIndexNumbers = readLocalData(self.showBoardIndexNumbersKey, df.showBoardIndexNumbers)
    self.highlightCurrentLevel = readLocalData(self.highlightCurrentLevelKey, df.highlightCurrentLevel)
    self.showLastMove=readLocalData(self.showLastMoveKey, df.showLastMove)
    self.showCapturingStone=readLocalData(self.showCapturingStoneKey, df.showCapturingStone)
    self.saveRestoreCurrentGame=readLocalData(self.saveRestoreCurrentGameKey, df.saveRestoreCurrentGame)   
    self.gameSoundOn=readLocalData(self.gameSoundOnKey, df.gameSoundOn)    
    self.playSpeed=readLocalData(self.playSpeedKey, df.playSpeed)   
    
    -- local s =string.format("blackPlayerName: %s   whitePlayerName: %s   gameBoardSizeKey: %d   playerModeKey: %d",self.blackPlayerName, self.whitePlayerName, self.gameBoardSize, self.playerMode)
    -- print(s)
    -- local s =string.format("showBoardIndrxNumbers:%s  showLastMove:%s  showCapturingStone:%s saveRestoreCurrentGame:%s gameSoundOn:%s",self.showBoardIndexNumbers, self.showLastMove, self.showCapturingStone,self.saveRestoreCurrentGame, self.gameSoundOn)
    -- print(s) 
end



function Settings:getPlaySpeedTme()
    local fast=0.1
    local normal=0.75
    local slow=2.0
    local turgid=3.5
    
    if self.playSpeed == PLAYSPEED_FAST then
        return fast
    elseif self.playSpeed == PLAYSPEED_NORMAL then
        return normal
    elseif self.playSpeed == PLAYSPEED_SLOW then
        return slow
    elseif self.playSpeed == PLAYSPEED_TURGID then
        return turgid
    else
        return normal
    end
    
end

function Settings :draw()
    -- Codea does not automatically call this method
end

function Settings :touched(touch)
    -- Codea does not automatically call this method
end









--# MenuPanel
MenuPanel = class()

function MenuPanel:init()
    collectgarbage()
    collectgarbage()
    collectgarbage()
    print("MenuPanel: init()")
    if CurrentOrientation == PORTRAIT 
    or CurrentOrientation == PORTRAIT_UPSIDE_DOWN then
        -- alert("portrait")
        print("menupanel portrait mode")
    end
    mpDrawFirstCounter=0
    theSettings:loadSettings()
    -- you can accept and set parameters here
    showKBForTextBox=false
    -- textbox accepting keyboard input, if any
    textBoxAcceptingInput = nil
    settingsChangeFlag = false
    self.restoreGameDialog = RestoreGameDialog(self)
    -- self.panelColor = bobgrayColor
    self.panelColor = lightslategrayColor
    
    fontSize(24)
    font("ArialRoundedMTBold")
    local t="New"
    local h=50
    local w= 150
    -- w = w + 40
    s = string.format("t=%s.   w=%d.  h=%d",t,w,h)
    print(s)
    self.newGameButton = MeshButton(t,0,0,w,h)
    self.newGameButton.action = function () self:newGame() end
    
    local t="Resume"
    
    
    --        t,0,0,w,h
    self.resumeGameButton = MeshButton(t,0,0,w,h)
    -- self.resumeGameButton = Button(t)
    self.resumeGameButton.action = function () resumeGame() end
    local t="Restore"
    
    self.restoreGameButton = MeshButton(t,0,0,w,h)
    self.restoreGameButton.action = function () self:restoreGame() end
    
    local t="Rules"
    
    self.rulesGameButton = MeshButton(t,0,0,w,h)
    self.rulesGameButton.action = function () rulesOfGame() end
    
    local t="About"
    
    self.aboutButton = MeshButton(t,0,0,w,h)
    self.aboutButton.action = function () self:aboutAlert() end
    
    local t="Settings"
    
    self.settingsButton = MeshButton(t,0,0,w,h)
    self.settingsButton.action = function () self:showSettingsDialog() end
    
    
    
    
    local t="Defaults"
    self.resetButton = MeshButton(t,0,0,w,h)
    self.resetButton.action = function () self:resetSettingsToDefault() end
    
    local t="ReInit"
    self.reInitButton = MeshButton(t,0,0,w,h)
    self.reInitButton.action = function () self:reinitializeGameAreYouSure() end
    -- mediumRB.checked = true
    
    
    self.settingsDialog=SettingsDialog()
    
    self.confirmResetToDefaultsMP = MessagePanel("Warning! Settings will be reset to default settings. Is this OK?")
    self.confirmResetToDefaultsMP.action = function() self:setSettingsToDefaults() end
    
    self.confirmReinitializeGameMP = MessagePanel("Warning! All saved games will be removed. All settings will be reset to default settings. Is this OK?")
    self.confirmReinitializeGameMP.action = function() self:reinitializeGame() end
    self.settingsAreSetToDefaultMP = MessagePanel("Settings are reset to default values.")
    self.settingsAreSetToDefaultMP.msgType=MESSAGE_PANEL_ALERT
    self.gameIsReinitializedMP = MessagePanel("Game is reinitialized.")
    self.gameIsReinitializedMP.msgType=MESSAGE_PANEL_ALERT
    
    local t="Exit"
    
    self.exitGameButton = MeshButton(t,0,0,w,h)
    self.exitGameButton.action = function () self:exitGame() end
    
    
    self.confirmLoseExistingMP = MessagePanel("Existing Game will be lost. Is this OK?")
    self.confirmLoseExistingMP.action = function() self:newBoard() end
    
    self.confirmResetToDefaultsMP = MessagePanel("Settings will be reset to default settings. Is this OK?")
    self.confirmResetToDefaultsMP.action = function() self:setSettingsToDefaults() end
    
    
    local str = string.format("%s v. %s\nCopyright: %s",gameName, gameVersion, COPYRIGHTSTR)
    self.aboutMP = MessagePanel(str)
    self.aboutMP.msgType = MESSAGE_PANEL_ALERT
    
    -- iPadAiName = "IPAD AI"
    
    
    local txt=theSettings.playerMode
    print("selected txt b4 costructor:")
    print(txt)
    self.selectPlayerModeDialog= SelectDialog(theSettings.playerModeTable, txt, theSettings.playerModeDisplayTable)
    self.selectPlayerModeDialog.action = function(selected) self:setPlayerMode(selected) end
    self.selectPlayerModeDialog.borderColor=slategrayColor
    
    self.playerModeSettingButton=Button(theSettings.playerModeDisplayTable[txt])
    self.selectPlayerModeDialog.minWidth=150
    self.playerModeSettingButton.action = function() self:selectPlayerMode() end
    self.playerModeSettingButton.minWidth=230
    
    local hText=theSettings.currentHandicap
    self.handicapSettingButton=Button(hText)
    self.handicapSettingButton.minWidth=80
    self.handicapSettingButton.action = function() self:selectHandicap() end
    
    -- self.handicapDialog=SelectHandicapDialog()



    self.handicapDialog= SelectDialog(theSettings.handicapTable, hText)
    self.handicapDialog.action = function(selected) self:setHandicap(selected) end
    self.handicapDialog.borderColor=slategrayColor
    self:refreshSettings()
    
end


function MenuPanel:draw()
    -- Codea does not automatically call this method
    local x,y = 0,0
    
    if gameState == GAMESTATE_BEGIN then
        self.resumeGameButton.disabled = true
    else
        self.resumeGameButton.disabled = false
    end
    y = HEIGHT
    y = y - 100

    x = WIDTH/2
    strokeWidth(5)
    fill(self.panelColor)
    local rectX = x - 400
    local rectY = y - 620
    local rectW=800
    local rectH=700
    local imgX = x
    local imgY = y
    local imgW = 275-- 8/3 aspect or sone such
    local imgH=100
    local logoX=x
    if CurrentOrientation == PORTRAIT 
    or CurrentOrientation == PORTRAIT_UPSIDE_DOWN then
        if mpDrawFirstCounter % 60 == 0 then
            print("draw oortrait")
        end
        y = y - 100
         rectX = x - 375
         rectY = y - 620
         rectW=750
         rectH=700   
         imgX = x
         imgY = y
        x = WIDTH/6 -30
    else
        x=WIDTH/6    
    end
    
    roundRect(rectX,rectY,rectW, rectH, 20)
    fill(whiteColor) 
    -- sprite("Documents:ziggurat _image3",imgX,imgY,w, h)
    sprite("Documents:Ziggurat_image1",imgX,imgY,imgW,imgH)
    
    y = imgY
    
    font("SnellRoundhand-Black")
    
    fontSize(64)
    -- fill(whiteColor)
    
    textMode(CENTER)
    fill(whiteClearColor)
    text(gameName, logoX, y)
    fill(cyanClearColor)
    text(gameName, logoX + 1, y + 1)
    font("SnellRoundhand-Black")
    
    fontSize(64)
    -- fill(whiteColor)
    fill(whiteClearColor)
    text(gameName, logoX, y)
    fill(cyanClearColor)
    text(gameName, logoX+ 1, y - 1)
    textMode(CENTER)
    fontSize(28)
    font("HelveticaNeue-Bold")
    y = y - 140

    

    local buttonStartY=y
    self.newGameButton.x = x
    self.newGameButton.y =  y
    self.newGameButton:draw()
    
    y = y - 70
    -- x = x - 20
    self.resumeGameButton.x = x
    self.resumeGameButton.y = y
    self.resumeGameButton:draw()
    
    y = y - 70
    self.restoreGameButton.x = x
    self.restoreGameButton.y = y
    self.restoreGameButton:draw()
    
    y = y - 70
    self.resetButton.x = x
    self.resetButton.y = y
    self.resetButton:draw()
    
    y = y - 70
    self.reInitButton.x = x
    self.reInitButton.y = y
    self.reInitButton:draw()
    
    
    
    y = y - 70
    self.exitGameButton.x =x
    self.exitGameButton.y =y
    self.exitGameButton:draw()
    
    y = y - 70
    
    
    
    spacer= 25
    
    
    
    y = buttonStartY
    x= WIDTH/2 + 120
    buttonStartX = x
    
    self.aboutButton.x = x
    self.aboutButton.y = y
    self.aboutButton:draw()
    y = y - 70
    
    self.rulesGameButton.x = x
    self.rulesGameButton.y = y
    self.rulesGameButton:draw()
    
    fontSize(24)
    font("HelveticaNeue-Bold")
    
    y = y -40
    x = x - 80
    fill(blackColor)
    text("Player Mode:",x,y)
    x = x + 205
    self.playerModeSettingButton.pos=vec2(x,y)
    self.playerModeSettingButton:draw()
    
    self.selectPlayerModeDialog.x=x+2
    self.selectPlayerModeDialog.y=y
    
    y = y - 60
    x = x - 188
    fill(blackColor)
    text("Handicap:",x,y)
    x = x + 113
    self.handicapSettingButton.pos=vec2(x,y)
    self.handicapSettingButton:draw()
    
    self.handicapDialog.x=x+2
    self.handicapDialog.y=y
    
    x = buttonStartX
    y = y -180
    
    self.settingsButton.x=x
    self.settingsButton.y=y
    self.settingsButton:draw()
    -- these only render if they are active
    self.confirmLoseExistingMP:draw()
    self.aboutMP:draw()
    self.confirmResetToDefaultsMP:draw()
    --
    self.confirmReinitializeGameMP:draw()
    self.settingsAreSetToDefaultMP:draw()
    self.gameIsReinitializedMP:draw()
    self.settingsDialog:draw()
    self.restoreGameDialog:draw()
    self.handicapDialog:draw()
    self.selectPlayerModeDialog:draw()
end


function MenuPanel:touched(touch)
    if self.settingsDialog.active then
        self.settingsDialog:touched(touch)
        return
    end
    if self.restoreGameDialog.active then
        self.restoreGameDialog:touched(touch)
        return
    end
    if self.confirmLoseExistingMP.active then
        self.confirmLoseExistingMP:touched(touch)
        return
    end
    if self.aboutMP.active then
        -- print("aboutMO active and touched")
        self.aboutMP:touched(touch)
        return
    end
    if self.confirmResetToDefaultsMP.active then
        -- print("aboutMO active and touched")
        self.confirmResetToDefaultsMP:touched(touch)
        return
    end
    if self.handicapDialog.active then
        if self.handicapDialog:touched(touch) then
            print("handicapDialog active and touched")
            self.handicapSettingButton.displayName=theSettings.currentHandicap
        end
        return
    end
    if self.confirmResetToDefaultsMP.active then
        -- print("aboutMO active and touched")
        self.confirmResetToDefaultsMP:touched(touch)
        return
    end
    if self.confirmReinitializeGameMP.active then
        -- print("aboutMO active and touched")
        self.confirmReinitializeGameMP:touched(touch)
        return
    end
    -- self.confirmReinitializeGameMP:draw()
    if self.settingsAreSetToDefaultMP.active then
        self.settingsAreSetToDefaultMP:touched(touch)
        return
    end
    
    if self.gameIsReinitializedMP.active then
        self.gameIsReinitializedMP:touched(touch)
        return
    end
    
    
    
    
    if self.selectPlayerModeDialog.active then
        if self.selectPlayerModeDialog:touched(touch) then
            print("handicapDialog active and touched")
            self.selectPlayerModeDialog.sbelected=theSettings.playerMode
        end
        return
    end
    
    
    if self.newGameButton:touched(touch) then
        return
    elseif self.resumeGameButton:touched(touch) then
        return
    elseif self.restoreGameButton:touched(touch) then
        return
    elseif self.resetButton:touched(touch) then
        return
    elseif self.reInitButton:touched(touch) then
        return
    elseif self.rulesGameButton:touched(touch) then
        return
    elseif self.aboutButton:touched(touch) then
        return
    elseif self.exitGameButton:touched(touch) then
        return
    elseif self.playerModeSettingButton:touched(touch) then
        return
    elseif self.handicapSettingButton:touched(touch) then
        return
    elseif self.settingsButton:touched(touch) then
        return
    end
    
    self:refreshSettings()
    theSettings:saveSettings()
    
end



function MenuPanel:refreshSettings()
    -- refresh player nam
    self.handicapSettingButton.displayName=theSettings.currentHandicap
    self.playerModeSettingButton.selected=theSettings.playerMode

    createDefaultInfoMessage()
end

function MenuPanel:selectHandicap()
    self.handicapDialog.active=true
end

function MenuPanel:selectPlayerMode()
    self.selectPlayerModeDialog.active=true
end

function MenuPanel:setPlayerMode(selected)
    print("MenuPanel:setPlayerMode(selected)")
    print(selected)
    theSettings.playerMode=selected
    local display=theSettings.playerModeDisplayTable[selected]
    self.playerModeSettingButton.displayName=display
    self:refreshSettings()
end

function MenuPanel:setHandicap(selected)
    print("MenuPanel:setHandicap(selected)")
    print(selected)
    theSettings.currentHandicap=selected
    self.handicapSettingButton.displayName=selected
    self:refreshSettings()
end


function  MenuPanel:resetSettingsToDefault()
    self.confirmResetToDefaultsMP.active=true
end


function  MenuPanel:exitGame()
    -- alert("exit - coming soonj")
    close()
end

function MenuPanel:aboutAlert()
    -- local str = string.format("Ziggurat v. %s\nCopyright: %s", gameVersion, "1984-1986, 2019-2020")
    -- alert(str, "
    self.aboutMP.active = true
end

function MenuPanel:showSettingsDialog()
    self.settingsDialog.active=true
end

function MenuPanel:restoreGame()
    -- alert("Future: restore saved game")
    self.restoreGameDialog = RestoreGameDialog(self)
    self.restoreGameDialog.active=true
end
function rulesOfGame()
    alert("Future: show rules Ziggurat")
end

function MenuPanel:newGame()
    print("new game - gamestate "..gameState)
    print("new game - playerMode "..theSettings.playerMode)
    
    if gameState == GAMESTATE_BEGIN then
        -- theAIPlayer = AIPlayer()
        createAIPlayers()
        createNewGameBoard()
    elseif gameState == GAMESTATE_NEW then
        -- recreate in case suze etc shanges
        -- theAIPlayer = AIPlayer()
        createAIPlayers()
        createNewGameBoard()
    elseif gameState == GAMESTATE_INPROGRESS then
        -- alert("Need confirm to destroy game in progress")
        print("new - game in progress")
        self.confirmLoseExistingMP.active = true
        return
    elseif gameState == GAMESTATE_WON then
        -- alert("Need confirm to destroy game
        -- theAIPlayer = AIPlayer()
        createAIPlayers()
        createNewGameBoard()
    end
    screenState = GAMEBOARD_SCREEN
end

function MenuPanel:newBoard()
    gameState = GAMESTATE_NEW
    -- theAIPlayer = AIPlayer()
    createAIPlayers()
    createNewGameBoard()
    screenState = GAMEBOARD_SCREEN
end


function checkHandicap()
    -- if gameboard has applied handicap we need to toggle move
    if theSettings.currentHandicap ~= "None" then
        gameState = GAMESTATE_INPROGRESS
        -- table.remove(theMoveTable,1)
        addMoveToTheMoveTable()
        toggleMove()
    end
end

function createNewGameBoard()
    mainInit()
    theGameBoard = GameBoard()
    checkHandicap()
    
end

function resumeGame()
    print("resume game - gamestate "..gameState)
    if gameState == GAMESTATE_BEGIN then
        alert("Resume game should be disabled at beginning, press new")
        return
    end
    createAIPlayers()
    theGameBoard:initializeMainPanelButtons()
    pauseAIvsAI=false
    screenState = GAMEBOARD_SCREEN
end



function  MenuPanel:resetSettingsToDefault()
    self.confirmResetToDefaultsMP.active=true
end

function MenuPanel:setSettingsToDefaults()
    theSettings:resetToDefaults()
    self:refreshSettings()
    self.settingsDialog:refreshSettings()
    self.settingsAreSetToDefaultMP.active=true
end

function  MenuPanel:reinitializeGameAreYouSure()
    self.confirmReinitializeGameMP.active=true
end

function MenuPanel:reinitializeGame()
    clearLocalData()
    theSettings:resetToDefaults()
    self:refreshSettings()
    self.settingsDialog:refreshSettings()
    mainInit()
    -- createNewGameBoard()
    theGameBoard=nil
    gameState = GAMESTATE_BEGIN
    self.gameIsReinitializedMP.active=true
end



function keyboard(key)
    if  key ~= nil and textBoxAcceptingInput ~= nil then
        textBoxAcceptingInput:acceptKey(key)
        
    end
end

--# MakeSounds
MakeSounds = class()
-- globals for sound() calls
function MakeSounds:init(x)
    -- you can accept and set parameters here
    self.x = x
end

function MakeSounds:draw()
    -- Codea does not automatically call this method
end

function MakeSounds:touched(touch)
    -- Codea does not automatically call this method
end

function makeAdvanceSound()
    print("makeAdvanceSound")
    sound(SOUND_JUMP, 12734)
end

function makeCaptureSound()
    print("makeCaptureSound")
    sound(SOUND_SHOOT, 12737)
end

function makeStoneClickSound()
    print("makeStoneClickSound")
    sound(SOUND_HIT, 12734)
    
end

function makeStoneChoiceSound()
    print("makeStoneChoiceSound")
    -- sound(SOUND_POWERUP, 12749)
    sound(SOUND_POWERUP, 12740)
end






--# AIPlayer
AIPlayer = class()

function AIPlayer:init(moveState)
    -- you can accept and set parameters here
    -- when add pater coice thes may be set to black
    print("aiPlayer:init")
    self.moveState = moveState or nil
    if self.moveState == WHITEMOVE then
        self.stoneState = WHITESTONESTATE
    elseif self.moveState == BLACKMOVE then
        self.stoneState = BLACKSTONESTATE
    else
        self.stoneState = hil
    end
    if self.moveState == nil then
        if isAIWhitePlayerMode() then
            print("setting AIPlayer to white")
            self.moveState = WHITEMOVE
            self.stoneState = WHITESTONESTATE
        elseif isAIBlackPlayerMode() then
            print("setting AIPlayer to black")
            self.moveState = BLACKMOVE
            self.stoneState = BLACKSTONESTATE
        end
    end 
    
    
    print(stoneStateText[self.stoneState])
    self.availableSquares = {}
    self.origAvailableSquares = {}

        self.weightedSquares = {}

    self.helper = AIHelper(self)
    self.helper:initLevelSideLoHiPairs()
    passedMoveFlag=false
end


function AIPlayer:move()
    -- tween.delay(1.0)
    print("AIPlayer:move()")
    print("self.moveState:%d", self.moveState) 
    addMoveToTheMoveTable()
    if chooseStoneAdvanceState then
        mainInfoMessage="AI choosing which stone to advance"
        -- self:chooseAdvanceStonesMoves()
        tween.delay(1.0,function() self:chooseAdvanceStonesMoves() end)
        tween.delay(1.1,function()  table.remove(theMoveTable, 1) end)
        -- table.remove(theMoveTable, 1)
        return
    end
    local mvBs = self:getBestMoveSquare()
    if mvBs == nil then
        mainInfoMessage="AI forced to pass"
        currentMove.pass=true
        -- alert(mainInfoMessage)
        print(mainInfoMessage)
        return
    end 

    printBSInfo("BestMove SQ before setStsState",mvBs)
    mvBs.aiStoneFlag = true
    mvBs:setStoneState()
    boardChangedState = true
    aiAdvancesAndCaptures()
    boardChangedState = true
    --[[
    aiAdvancesAndCaptures()
    boardChangedState = true
    aiAdvancesAndCaptures()
      ]]
end

function AIPlayer:chooseAdvanceStonesMoves()
    self:checkChooseAdvanceStones()
    aiAdvancesAndCaptures()
    self:checkChooseAdvanceStones()
    aiAdvancesAndCaptures()
    self:checkChooseAdvanceStones()
    aiAdvancesAndCaptures()
    toggleMove()
    checkStateOfTheBoard()
    --[[
    self:checkChooseAdvanceStones()
    aiAdvancesAndCaptures()
    self:checkChooseAdvanceStones()
    aiAdvancesAndCaptures()
      ]]
end

function AIPlayer:checkChooseAdvanceStones()
    
    local bs = self:getBestAIchoiceStone()
    if bs== nil then
        return false
    end
    printBSInfo("AI Sq chosen to advance",bs)
    bs.aiStoneFlag = true
    bs.topNeighbor.choiceStoneFlag=true
    bs:setStoneState()
    -- handle the 5 in a row case, 3 stones capable of advancing
    local sz=# advanceStonesTable
    if sz > 2 then
        local rn = bs.rightNeighbor
        local rn1 = rn.rightNeighbor
        --[[
        local rn2 = rn1.rightNeighbor
        local rn3 = rn2.rightNeighbor
          ]]
        local ln = bs.leftNeighbor
        local ln1 = ln.leftNeighbor
        for i = 1, sz do
            local bs2 = advanceStonesTable[i]
            if bs2.index == rn1.index or bs2.index == ln1.index then
                -- bingo! we have another stone to advance
                -- check corner case where only 1stone can advance
                if bs.topNeighbor.index == bs2.topNeighbor.index then
                    goto zbreak
                end
                printBSInfo("AI Sq chosen to advance",bs)
                -- bs2.aiStoneFlag = true
                bs2.topNeighbor.choiceStoneFlag=true
                bs2:setStoneState()
                if theSettings.gameSoundOn then
                    -- sound(SOUND_JUMP, 12737)
                    makeAdvanceSound()
                end
            end
        end
    end
    ::zbreak::
    clearStoneChooseFlags()
    advanceStonesTable = {}
    boardChangedState=true 
    return true
end

function AIPlayer:getBestAIchoiceStone()
    if next(advanceStonesTable) == nil then
        -- if table is empty, do nothing and reset (shouldnt happen)
        print("advanceStonesTable empty")
        chooseStoneAdvanceState = false
        return nil
    end
    local sz = # advanceStonesTable
    -- local idx = math.random(1,sz)
    local bs= nil
    local weightedAdvTable={}
    for idx = 1, sz do
        bs = advanceStonesTable[idx]
        local rn = bs.rightNeighbor
        local rn2 = rn.rightNeighbor
        local rn3 = rn2.rightNeighbor
        local ln = bs.leftNeighbor
        local ln2 = ln.leftNeighbor
        local ln3 = ln2.leftNeighbor
        local ss = self.stoneState
        local opss = self.helper:getOpponentStone(ss)
        if rn2.stoneState == opss then
            -- no weighting
            table.insert(weightedAdvTable,bs)
        elseif ln2.stoneState == opss then
            -- no weighting
            table.insert(weightedAdvTable,bs)
        else
            for i=1, WTMAG5 do
                -- no weighting
                table.insert(weightedAdvTable,bs)
            end
        end
    end
    sz=#weightedAdvTable
    local idx  = math.random(1, sz)
    bs=weightedAdvTable[idx]
    return bs
end


function aiAdvancesAndCaptures()
    print("aiAdvancesAndCaptures")
    chooseStoneAdvanceState = false
    clearStoneChooseFlags()
    advanceStonesTable = {}
    displayJustCapturedMsg=false
    --  print("choice made returning after advanceStonesTable check")
    -- the choice may resolt in other changes
    while boardChangedState do
        boardChangedState = false
        checkBoardForCapturesAndAdvancements()
    end
    -- toggleMove()
    -- checkStateOfTheBoard()
    -- checkBoardForCapturesAndAdvancements()
    -- interrupt drawing to see if it removes sluggishness
    -- drawInterruptus = true
    return    
end

function AIPlayer:getBestMoveSquare()
    self.availableSquares = self:getAvailableBoardSquares()
    self.origAvailableSquares = self:getAvailableBoardSquares()
    if currentPlayLevel == 7 then
        -- only one square
        return self.availableSquares[1]
    end
    
    self.weightedSquares = self:getWeightedSquares()
    local numAvail=# self.weightedSquares
    if numAvail == 0 then
        numAvail = # self.origAvailableSquares
        if numAvail == 0 then
            print("AI must pass")
            return nil
        else 
            self.weightedSquares = self.origAvailableSquares
        end
    end
    math.randomseed(os.time())
    local idx = math.random(1, numAvail)
    print(idx)
    -- idx = math.floor(idx)
    -- print(idx)
    local mvBs = self.weightedSquares[idx]
    return mvBs
end






-- adding weight means to add copies of sqs tothe randomizor
-- occasionally we rm sqs from consideration
function AIPlayer:getWeightedSquares()
    print("getWeightedSquares")
    self.helper.unicornFlag = false
    self:removeImmediateCaptures()
    local weightedSquares = self.availableSquares
    if currentPlayLevel < 5 then
        weightedSquares = self.helper:getWeightedLocationSquares()
    end
    weightedSquares  = self:getWeightedForCanCaptureSquares(weightedSquares)
    weightedSquares  = self.helper:getWeightedPreventCaptureSquares(weightedSquares)
    self.helper:addWeightedShapeSquares(weightedSquares)
    self.helper:addWeightedThreatenCaptureSquares(weightedSquares)
    self.helper:addWeightedSacrificeSquares(weightedSquares)
    self.helper:addWeightedAdvanceSquares(weightedSquares)
    -- print("AIPlayer calling self.helper:trimWeightedSquares")
    weightedSquares = self.helper:trimWeightedSquares(weightedSquares)
    return weightedSquares
end

function AIPlayer:getWeightedForCanCaptureSquares(weightedSquares)
    -- this should be called after isCapturable have been removed
    local avl = self.availableSquares
    local num = #avl
    ss = self.stoneState
    local canCaptureTable = {}
    for i = 1, num do
        local bs = avl[i]
        local rn = bs.rightNeighbor
        local ln = bs.leftNeighbor
        if ss == WHITESTONESTATE then
            if rn.stoneState == BLACKSTONESTATE and rn.rightNeighbor.stoneState == WHITESTONESTATE then
                table.insert(canCaptureTable, bs)
             elseif ln.stoneState == BLACKSTONESTATE and ln.leftNeighbor.stoneState == WHITESTONESTATE then   
                table.insert(canCaptureTable, bs)
            end
        elseif ss == BLACKSTONESTATE then
            if rn.stoneState == WHITESTONESTATE and rn.rightNeighbor.stoneState == BLACKSTONESTATE then
                table.insert(canCaptureTable, bs)
             elseif ln.stoneState == WHITESTONESTATE and ln.leftNeighbor.stoneState == BLACKSTONESTATE then   
                table.insert(canCaptureTable, bs)
            end  
        end
    end -- end for
    local capSize = # canCaptureTable
    -- print ("cap table size: "..capSize)
    if capSize == 0 then
        return weightedSquares
    end
    -- dumpSpecifiedBsTable(canCaptureTable)
    local wt = WTMAG16
    for i = 1, capSize do
        local bs = canCaptureTable[i]
        for j = 1, wt do
            table.insert(weightedSquares,bs)
        end
    end
    -- dumpSpecifiedBsTable(weightedSquares)
    return weightedSquares

end


function AIPlayer:removeImmediateCaptures()
    print("removeImmediateCaptures")
    local numAvail = # self.availableSquares
    -- this a stack of indexes to remove
    -- remove backwards
    local removeList = {}
    for i = 1, numAvail do
        local bs = self.availableSquares[i]
        if self:isImmediateCapture(bs) then
            table.insert(removeList,1,i)
        elseif self:isSuicideMove(bs) then
            printBSInfo("found suicide move",bs)
            table.insert(removeList,1,i)
        end
    end
    rmsz = #removeList
    print("remove list size: "..rmsz)
    if rmsz == 0 then
        -- print("no immediate captures found")
        return
    elseif rmsz >= # self.availableSquares then
        -- print("whoops we do not want to remove all available")
        return
    end
    -- print("removing imd capture from available")
    for j=1, rmsz do
        idx =  table.remove(removeList, 1 )
        -- print("imdCap - rm from avail idx = "..idx)
        rmbs = table.remove(self.availableSquares, idx)
        -- print("removed from available, bs level,index: ", rmbs.level, rmbs.index)
        
    end
    -- fall thru remove bs from available
    
end

function AIPlayer:isImmediateCapture(bs) 
    -- print("isImmediateCapture")
    local rn = bs.rightNeighbor
    local ln = bs.leftNeighbor
    local ss = self.stoneState
    -- print (self.stoneState)
    -- print("self stoneState:"..ss)
    -- print("rn stoneState:"..rn.stoneState)
    -- print("ln stoneState:"..ln.stoneState)
    if currentPlayLevel == 7 then
        return false
    end
    
    if ss == WHITESTONESTATE  then
        if rn.stoneState == BLACKSTONESTATE and ln.stoneState == EMPTYSTONESTATE then
            if rn.rightNeighbor.stoneState == WHITESTONESTATE then
                -- this stone dan be capture
                -- print("capturable: "..bs.level..","..bs.index)
                return false
            end
            return true
        elseif rn.stoneState == EMPTYSTONESTATE and ln.stoneState == BLACKSTONESTATE then
            if ln.leftNeighbor.stoneState == WHITESTONESTATE then
                -- this stone dan be capture
                -- print("capturable: "..bs.level..","..bs.index)
                return false
            end
            return true
        end
    elseif ss == BLACKSTONESTATE then
        if rn.stoneState == WHITESTONESTATE and ln.stoneState == EMPTYSTONESTATE then
            if rn.rightNeighbor.stoneState == BLACKSTONESTATE then
                -- this stone dan be capture
                return false
            end
            return true
        elseif rn.stoneState == EMPTYSTONESTATE and ln.stoneState == WHITESTONESTATE then
            if ln.leftNeighbor.stoneState == BLACKSTONESTATE then
                -- this stone dan be capture
                return false
            end
            return true
        end     
    end
    -- ,fall thru
    return false
end

function AIPlayer:isSuicideMove(bs) 
    -- suicide move is to add one stone to a two stone group which results in a 3 stone group
    -- with an opponent stone on each side; if the middle stone advances, the opponent captures the 
    -- remaining two stones with one move. if the top stone of the middle is occupied you are ok
    -- note as a level fills up, you are sometimes forced to make suicide mi
    -- printBSInfo("isSuicideMove check", bs)
    local rn = bs.rightNeighbor
    local rn2 = rn.rightNeighbor
    local rn3 = rn2.rightNeighbor 
    local ln = bs.leftNeighbor
    local ln2 = ln.leftNeighbor 
    local ln3 = ln2.leftNeighbor 
    local ss = self.stoneState
    local opss = self.helper:getOpponentStone(ss)
    -- look for oponent surounding 3 sqs
    if rn.stoneState == opss and ln3.stoneState == opss then
        -- what is in the middle
        -- print("oponent surrounds 3 sqs")
        if ln2.stoneState == ss and ln.stoneState == ss then
            -- print("2 of my stones in a row")
            -- 2 in a row, but is there a top neighbor
            if ln.topNeighbor.stoneState == EMPTYSTONESTATE then 
                -- print("empty top neighbor")
                return true
            end
        end
    elseif ln.stoneState == opss and rn3.stoneState == opss then
        -- print("oponent surrounds 3 sqs")
        -- what is in the middle
        if rn2.stoneState == ss and rn.stoneState == ss then
            -- 2 in a row, but is there a top neighbor
            -- print("2 of my stones in a row")
            if rn.topNeighbor.stoneState == EMPTYSTONESTATE then 
                -- print("empty top neighbor")
                return true
            end
        end
    end
    -- there is the case where the middle stones are in suicide position that we dont check
    -- fall thru false
    return false
end

function AIPlayer:getAvailableBoardSquares()
    local stoneState = EMPTYSTONESTATE
    local sqTable = {} 
    if self.moveState == WHITEMOVE then 
        stoneState = WHITESTONESTATE
    elseif self.moveState == BLACKMOVE then
        stoneState = BLACKSTONESTATE
    end
    for i=1, numSquares do
        bs = bsTable[i] 
        if bs:isPlayableSquare(stoneState) then
            table.insert(sqTable, bs)
        end
    end
    return sqTable
end

function AIPlayer:draw()
    -- Codea does not automatically call this method
end
 
function AIPlayer:touched(touch)
    -- Codea does not automatically call this method
end





  

--# AIHelper
AIHelper = class()

-- weight magnitude conctants
WTMAG1 = 1
WTMAG2 = 2
WTMAG3 = 4
WTMAG4 = 8
WTMAG5 = 16
WTMAG6 = 32
WTMAG7 = 64
WTMAG8 = 128
WTMAG9 = 256
WTMAG10 = 512
WTMAG11 = 1024
WTMAG12 = 2048
WTMAG13 = 4096
WTMAG14 = 8192
WTMAG15 = 16384
WTMAG16 = 32768
WTMAG17 = 65536
WTMAG18 = 131072
WTMAG19 = 262144


-- used by AI
SOUTH_BOARD_SIDE = 1
EAST_BOARD_SIDE = 2
NORTH_BOARD_SIDE = 3
WEST_BOARD_SIDE = 4

function AIHelper:init(aiPlayer)
    -- you can accept and set parameters here
    self.player = aiPlayer
    self.unicornFlag = false
end



function AIHelper:addWeightedAdvanceSquares(weightedSquares)
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn) 
    local avl = self.player.availableSquares
    local num = # avl
    local advanceableTable = {}
    for i=1, num do
        local bs = avl[i]
        -- if a ai stone will be captured we see if there areavilable sq that will save it
        if self:willAdvanceStone(bs) then
            printBSInfo("willAdvance",bs)
            table.insert(advanceableTable,bs)
        end
    end
    sz  = # advanceableTable
    print("size advanceableTable: "..sz)
    local wt = WTMAG4
    if currentTurnNumber < 8 then
            local wt = WTMAG2
    end  
    if currentPlayLevel > 5 then
        -- if you advance at level 6 you win!
        local wt = WTMAG18
    elseif currentPlayLevel > 4 then
        local wt = WTMAG18
    elseif currentPlayLevel > 3 then
        local wt = WTMAG12
    elseif currentPlayLevel > 2 then
        local wt = WTMAG8
    end
    for i = 1, sz do
        adv = advanceableTable[i]
        for i=1, wt do
            table.insert(weightedSquares, adv)
        end
    end 
end

function AIHelper:willAdvanceStone(bs)
    -- print("willAdvanceStone")
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn) 
    local rn = bs.rightNeighbor
    local rn1 = rn.rightNeighbor
    local rn2 = rn1.rightNeighbor
    local rn3 = rn2.rightNeighbor
    local rn4 = rn3.rightNeighbor
    local ln = bs.leftNeighbor
    local ln1 = ln.leftNeighbor
    local ln2 = ln1.leftNeighbor
    local ln3 = ln2.leftNeighbor
    local ln4 = ln3.leftNeighbor
    local top= bs.topNeighbor
    local rnTop= rn.topNeighbor
    local lnTop= ln.topNeighbor
    local advBs = false
    local advRn = false
    local advLn = false
    
    -- check board square and appropriate neighbors
    if top.stoneState == EMPTYSTONESTATE
    and rn.stoneState == stn
    and ln.stoneState == stn  then
        -- if advance ooens up capture dont weight it
        if rn1.stoneState == opStn
        or ln1.stoneState == opStn then
            return false
        else
            -- printBSInfo("bs is advanceable,bs",bs)
            return true
        end
    elseif rn.stoneState == stn
    and rnTop.stoneState == EMPTYSTONESTATE
    and rn1.stoneState == stn then
        -- if advance ooens up capture dont weight it
        if rn2.stoneState == opStn
        or ln.stoneState == opStn then
            return false
        else
            -- printBSInfo("rn is advanceable",rn)
            return true
        end
    elseif ln.stoneState == stn
    and lnTop.stoneState == EMPTYSTONESTATE
    and ln1.stoneState == stn then
        -- if advance ooens up capture dont weight it
        if ln2.stoneState == opStn
        or rn.stoneState == opStn then
            return false
        else
            -- printBSInfo("ln is advanceable",ln)
            return true
        end
    end
    -- fall thru return false
    return false
end


-- rm low chance items
function AIHelper:trimWeightedSquares(weightedSquares)
    print("trimWeightedSquares")
    local num=#weightedSquares
    local n=0
    local hi=0
    local bs=nil
    local prev=nil
    print("num:"..num)
    newWeightedSquares={}
    table.sort(weightedSquares, function(a,b) self:compareBS(a,b) end)
    local sanity=0

    for i = 1, num do        
        --[[
        sanity = sanity + 1
        if sanity > 1000000 then
            goto zbreak
        end
          ]]
        -- print("i:"..i)
        
        bs = weightedSquares[i]
        
        if i > 1 then
            -- printBSInfo("trim weighted squares",bs)
            
            if self:equalBS(bs,prev) then
                n = n + 1
            else
                
                if n > WTMAG2 then
                    for j=1,n do
                        sanity = sanity + 1
                        if sanity > 100000 then
                            goto zbreak
                        end
                        -- print("j:"..j)
                        table.insert(newWeightedSquares,prev)
                    end
                    
                end
                n=0
            end

            
        end
        
        prev = bs

    end
    ::zbreak::
      print("size newWeightedSquares:"..#newWeightedSquares)
    if #newWeightedSquares == 0 then
        return weightedSquares
    end
    -- returned the trimmed version
    return newWeightedSquares
    
end
        --[[

    print("logic error")
    return weightedSquares
end
  ]]

function AIHelper:equalBS(bs1,bs2)
    return bs1.level == bs2.level and bs1.index == bs2.index
end
function AIHelper:compareBS(bs1,bs2)
    return bs1.level < bs2.level or bs1.index < bs2.index
end

-- offer piece for capture to improve shape ir position
function AIHelper:addWeightedSacrificeSquares(weightedSquares)
    print("addWeightedSacrificeSquares")
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn)
    local empty = EMPTYSTONESTATE
    
    local avl = self.player.origAvailableSquares  
    local num = # avl 
    local sacrificeTable = {}
    for i=1, num do
        local bs = avl[i]
        local rn = bs.rightNeighbor
        local rn1 = rn.rightNeighbor
        local rn2 = rn1.rightNeighbor
        local rn3 = rn2.rightNeighbor
        local rn4 = rn3.rightNeighbor
        local ln = bs.leftNeighbor
        local ln1 = ln.leftNeighbor
        local ln2 = ln1.leftNeighbor
        local ln3 = ln2.leftNeighbor
        local ln4 = ln3.leftNeighbor
        if rn.stoneState == opStn 
        and ln1.stoneState == stn
        and ln.stoneState == empty then       
            if ln2.stoneState == empty then
                printBSInfo("Adding weight as sacrifice", bs)
                for i=1, WTMAG3 do
                    table.insert(weightedSquares, bs)
                end
            elseif ln2.stoneState == stn then
                printBSInfo("Adding weight as sacrifice", bs)
                for i=1, WTMAG5 do
                    table.insert(weightedSquares, bs)
                end
                
            end
        elseif ln.stoneState == opStn 
        and rn1.stoneState == stn
        and rn.stoneState == empty then       
            if rn2.stoneState == empty then
                printBSInfo("Adding weight as sacrifice", bs)
                for i=1, WTMAG3 do
                    table.insert(weightedSquares, bs)
                end
            elseif rn2.stoneState == stn then
                printBSInfo("Adding weight as sacrifice", bs)
                for i=1, WTMAG5 do
                    table.insert(weightedSquares, bs)
                end
                
            end
            -- rare but i encounter it in most games
        elseif rn4.stoneState == stn
        and ln.stoneState == opStn
        and rn1.stoneState == opStn
        and rn2.stoneState == opStn
        and rn.stoneState == empty
        then
            printBSInfo("Adding weight as sacrifice", bs)
            for i=1, WTMAG5 do
                table.insert(weightedSquares, bs)
            end
        elseif ln4.stoneState == stn
        and rn.stoneState == opStn
        and ln1.stoneState == opStn
        and ln2.stoneState == opStn
        and ln.stoneState == empty
        then
            printBSInfo("Adding weight as sacrifice", bs)
            for i=1, WTMAG5 do
                table.insert(weightedSquares, bs)
            end
        end
    end
    
    

end



-- look for sqs that threaten capture, "safely"
function AIHelper:addWeightedThreatenCaptureSquares(weightedSquares)
    
    -- use origbbefore it wasvpruned
    local avl = self.player.origAvailableSquares  
    local num = # avl
    
    local threatenCaptureTable = {}
    for i=1, num do
        local bs = avl[i]
        -- printBSInfo("sq for good sh",bs)
        -- if a ai ston
        if self:canThreatenCapture(bs) then
            printBSInfo("sq can threaten capture",bs)
            table.insert(threatenCaptureTable,bs)
        end
    end
    sz  = # threatenCaptureTable
    print("size threatenCaptureTable: "..sz)
    for i = 1, sz do
        bs = threatenCaptureTable[i]
        for i=1, WTMAG9 do
            table.insert(weightedSquares, bs)
        end
    end 
end

function AIHelper:canThreatenCapture(bs)
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn)
    local rn = bs.rightNeighbor
    local rn1 = rn.rightNeighbor
    local rn2 = rn1.rightNeighbor
    local rn3 = rn2.rightNeighbor
    local ln = bs.leftNeighbor
    local ln1 = ln.leftNeighbor
    local ln2 = ln1.leftNeighbor
    local ln3 = ln2.leftNeighbor
    -- this square is available and empty
    -- look to the right
    if rn.stoneState == opStn and rn1.stoneState == EMPTYSTONESTATE then
        -- potential threat, is it safe?
        if ln.stoneState == stn then
            if ln1.stoneState == EMPTYSTONESTATE or ln1.stoneState == opStn then
                -- we end up with 2 and only 2 stns in a row
                return true
            end
            -- make sure we're not going to pop up on the left
            if ln2.stoneState == stn then
                -- we will have at least 3 in a row. but 4 in a row or a top stone ok
                if ln.topNeighbor.stoneState ~= EMPTYSTONESTATE then
                    -- our lnbir wont popup
                    return true
                elseif ln3.stoneState == stn then
                    -- 4 in a row means we can advance w.o exposing the threatentocapt stone
                    return true
                end
            elseif ln.stoneState == EMPTYSTONESTATE 
            and ln.topNeighbor == EMPTYSTONESTATE then
                -- possible sacrifice if we can apture back after justcaptured expires, thus too check
                -- need two in a row so we threaten oponent capt stone
                if ln1.stoneState == stn and ln2.stoneState == stn then
                    return true
                end
            elseif ln.stoneState == stn then
                if ln1.stoneState == EMPTYSTONESTATE or ln1.stoneState == opStn then
                    -- we end up with 2 and only 2 stns in a row
                    return true
                end
                -- make sure we're not going to pop up on the left
                if ln2.stoneState == stn then
                    -- we will have at least 3 in a row. but 4 in a row or a top stone ok
                    if ln.topNeighbor.stoneState ~= EMPTYSTONESTATE then
                        -- our lnbir wont popup
                        return true
                    elseif ln3.stoneState == stn then
                        -- 4 in a row means we can advance w.o exposing the threatentocapt stone
                        return true
                    end
                elseif ln.stoneState == EMPTYSTONESTATE 
                and ln.topNeighbor == EMPTYSTONESTATE then
                    -- possible sacrifice if we can apture back after justcaptured expires, thus too check
                    -- need two in a row so we threaten oponent capt stone
                    if ln1.stoneState == stn and ln2.stoneState == stn then
                        return true
                    end
                end
            end
        end
    end
    -- look to the left
    if ln.stoneState == opStn and ln1.stoneState == EMPTYSTONESTATE then
        -- potential threat, is it safe?
        if rn.stoneState == stn then
            if rn1.stoneState == EMPTYSTONESTATE or rn1.stoneState == opStn then
                -- we end up with 2 and only 2 stns in a row
                return true
            end
            -- make sure we're not going to pop up on the left
            if rn2.stoneState == stn then
                -- we will have at least 3 in a row. but 4 in a row or a top stone ok
                if rn.topNeighbor.stoneState ~= EMPTYSTONESTATE then
                    -- our lnbir wont popup
                    return true
                elseif rn3.stoneState == stn then
                    -- 4 in a row means we can advance w.o exposing the threatentocapt stone
                    return true
                end
            elseif rn.stoneState == EMPTYSTONESTATE 
            and rn.topNeighbor == EMPTYSTONESTATE then
                -- possible sacrifice if we can apture back after justcaptured expires, thus too check
                -- need two in a row so we threaten oponent capt stone
                if rn1.stoneState == stn and rn2.stoneState == stn then
                    return true
                end
            elseif rn.stoneState == stn then
                if rn1.stoneState == EMPTYSTONESTATE or rn1.stoneState == opStn then
                    -- we end up with 2 and only 2 stns in a row
                    return true
                end
                -- make sure we're not going to pop up on the left
                if rn2.stoneState == stn then
                    -- we will have at least 3 in a row. but 4 in a row or a top stone ok
                    if rn.topNeighbor.stoneState ~= EMPTYSTONESTATE then
                        -- our lnbir wont popup
                        return true
                    elseif rn3.stoneState == stn then
                        -- 4 in a row means we can advance w.o exposing the threatentocapt stone
                        return true
                    end
                elseif rn.stoneState == EMPTYSTONESTATE 
                and rn.topNeighbor == EMPTYSTONESTATE then
                    -- possible sacrifice if we can apture back after justcaptured expires, thus too check
                    -- need two in a row so we threaten oponent capt stone
                    if rn1.stoneState == stn and rn2.stoneState == stn then
                        return true
                    end
                end
            end
        end
    end
    return false
end

function AIHelper:addWeightedShapeSquares(weightedSquares)
    -- examine level and weight sqa that result in "good shape"
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn) 
    local avl = self.player.availableSquares
    local num = # avl
    local goodShapeTable = {}
    for i=1, num do
        local bs = avl[i]
        -- printBSInfo("sq for good shape",bs)
        -- if a ai stone will be captured we see if there areavilable sq that will save it
        if self:isGoodShape(bs) then
            -- printBSInfo("is good shape",bs)
            table.insert(goodShapeTable,bs)
        end
    end
    sz  = # goodShapeTable
    print("size goodShapeTable: "..sz)
    local wt = WTMAG6
    if currentTurnNumber < 8 then
            local wt = WTMAG1
    end
    
    
    for i = 1, sz do
        shp = goodShapeTable[i]
        for i=1, wt do
            table.insert(weightedSquares, shp)
        end
    end 
end

function AIHelper:isGoodShape(bs)
    -- see if squarecan create a shape with 2 spaces betwenn it and another stone either stone
    -- need lots of neighbors=
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn)
    local rn = bs.rightNeighbor
    local rn1 = rn.rightNeighbor
    local rn2 = rn1.rightNeighbor
    -- local rn3 = rn2.rightNeighborw
    local ln = bs.leftNeighbor
    local ln1 = ln.leftNeighbor
    local ln2 = ln1.leftNeighbor

    -- local ln3 = ln2.leftNeighbor
    -- bs is available so its empty - rn 2 is two spaces away
    if rn2.stoneState ~= EMPTYSTONESTATE then
        -- printBSInfo("checking on right to see if this is good shape", bs)
        if ln.stoneState == EMPTYSTONESTATE  -- backside has to be empty
        and rn.stoneState == EMPTYSTONESTATE
        and rn1.stoneState == EMPTYSTONESTATE then
            return true
        end
    end
    -- fall thru check left
    if ln2.stoneState ~= EMPTYSTONESTATE then
        -- printBSInfo("checking on left to see if this is good shape", bs)
        if rn.stoneState == EMPTYSTONESTATE
        and ln.stoneState == EMPTYSTONESTATE
        and ln1.stoneState == EMPTYSTONESTATE then
            return true
        end
    end
    -- fall thru after a certain point, doubling up stones might be good
    if theGameBoard.hasHandicap then
        -- keep looking for good shape
    elseif currentTurnNumber < 4 then
        -- distribution is more important
        return false
    end
    -- if neighbor is our stoneState, shape might be good
    if rn.stoneState == self.player.stoneState then
        if rn1.stoneState == EMPTYSTONESTATE
        and ln.stoneState == EMPTYSTONESTATE then
            return true
        end
    end
    if ln.stoneState == self.player.stoneState then
        if ln1.stoneState == EMPTYSTONESTATE
        and rn.stoneState == EMPTYSTONESTATE then
            return true
        end
    end
    -- if 2 stones in a row with an emoty stone in berween, good shape to place stone to prevent 3 jn a row 
    if rn1.stoneState == self.player.stoneState
    and rn2.stoneState == self.player.stoneState 
    and rn.stoneState == EMPTYSTONESTATE then 
        return true
    elseif ln1.stoneState == self.player.stoneState
    and ln2.stoneState == self.player.stoneState
    and ln.stoneState == EMPTYSTONESTATE then  
        return true
    end
    -- placing a stone 2 spaces from your own or an opponent is ysually good shape
    if (rn2.stoneState == stn or rn2.stoneState == opStn)
    and rn.stoneState == EMPTYSTONESTATE 
    and rn1.stoneState == EMPTYSTONESTATE then 
        return true
    elseif (ln2.stoneState == stn or ln2.stoneState == opStn)
    and ln.stoneState == EMPTYSTONESTATE 
    and ln1.stoneState == EMPTYSTONESTATE then    
        return true
    end
    return false
end

function AIHelper:addToGoodShape(bs, goodShapeTable)
    if  self:isInAvailable(bs) then
        table.insert(goodShapeTabl,bs)
    end
end

function AIHelper:getWeightedPreventCaptureSquares(weightedSquares)
    local stn = self.player.stoneState
    local opStn  = self:getOpponentStone(stn)
    local lvlSqs = theGameBoard.levelIndexTable[currentPlayLevel]
    local num = # lvlSqs
    local prevCapTable = {}
    for i=1, num do
        local bs = lvlSqs[i]
        -- printBSInfo("sq for prevCapture",bs)
        -- if a ai stone will be captured we see if there areavilable sq that will save it
        if self:canBeCaptured(bs) then
            -- printBSInfo("sq is capturable",bs)
            self:addToPreventCaptures(bs, prevCapTable)
        end
     end
    sz  = # prevCapTable
    local wt = WTMAG16
    for i = 1, sz do
        prv = prevCapTable[i]
        for i=1, wt do
            table.insert(weightedSquares, prv)
        end
    end
    return weightedSquares
end

function AIHelper:canBeCaptured(bs)
    local stn = self.player.stoneState
    -- print("player.stoneState",stn)
    local opStn  = self:getOpponentStone(stn)
    local empty = EMPTYSTONESTATE
    -- printBSInfo("considering for canBeCapt",bs)
    
    if stn == bs.stoneState then 
        -- we have a candidate
        -- printBSInfo("capturable canditate", bs)
    else
        return false 
    end
    -- for now, if there is an empty stone on one side and an opstn 
    -- the other we condider it capturable
    local rn = bs.rightNeighbor
    local ln = bs.leftNeighbor
    -- printBSInfo("right neighbor", rn)
    -- printBSInfo("left neighbor", ln)
    if rn.stoneState == opStn and ln.stoneState == empty 
        or rn.stoneState == empty and ln.stoneState == opStn then
        return true
    end
    -- fall thru: not capturabl
end


function AIHelper:addToPreventCaptures(bs, prevCapTable)
    -- this sq is capturable, it has an emptySquare neighbor
    -- if the empty square is on the avail list we add to table
    if self.player.stoneState ~= bs.stoneState then
        return prevCapTable
    end
    local rn = bs.rightNeighbor
    local ln = bs.leftNeighbor
    if rn.stoneState == EMPTYSTONESTATE and self:isInAvailable(rn) then
        table.insert(prevCapTable,rn)
    elseif ln.stoneState == EMPTYSTONESTATE and self:isInAvailable(ln) then
            table.insert(prevCapTable,ln)      
    end
end

function AIHelper:isInAvailable(bs)
    local avl = self.player.availableSquares
    local num = # avl
    for i=1, num do
        av = avl[i]
        if bs.level == av.level and av.index == bs.index then
            return true
        end
    end
    return false
end



function AIHelper:getOpponentStone(stoneState)
    if stoneState == WHITESTONESTATE then 
        return BLACKSTONESTATE
    elseif stoneState == BLACKSTONESTATE then
        return WHITESTONESTATE
    else   
        return 0
    end
    
end

function AIHelper:draw()
    -- Codea does not automatically call this method
end



function AIHelper:getWeightedLocationSquares()
    local southSqTable = self:getSideSquares(currentPlayLevel, SOUTH_BOARD_SIDE)
    local eastSqTable = self:getSideSquares(currentPlayLevel, EAST_BOARD_SIDE)
    local northSqTable = self:getSideSquares(currentPlayLevel, NORTH_BOARD_SIDE)
    local westSqTable = self:getSideSquares(currentPlayLevel, WEST_BOARD_SIDE)
    -- print("southSqTable")
    -- dumpSpecifiedBsTable(southSqTable)
    local southSideCount = 0
    local eastSideCount = 0
    local northSideCount = 0
    local westSideCount = 0
    -- increasing the odds that a play is made on a side with fewer of our stones
    -- local stoneState = EMPTYSTONESTATE
    local stState = self.player.stoneState
    -- print("stoneState"..stoneStateText[stState])
    for i = 1, #  southSqTable do
        local bs = southSqTable[i]
        
        -- printBSInfo("southCount", bs)
        if bs.stoneState == stState then
            southSideCount = southSideCount + 1
        end
    end
    for i = 1, #  eastSqTable do
        local bs = eastSqTable[i]
        
        -- printBSInfo("eastCount", bs)
        if bs.stoneState == stState then
            eastSideCount = eastSideCount + 1
        end
    end
    
    for i = 1, #  northSqTable do
        local bs = northSqTable[i]
        -- printBSInfo("northCount", bs)
        if bs.stoneState == stState then
            northSideCount = northSideCount + 1
        end
    end
    for i = 1, #  westSqTable do
        local bs = westSqTable[i]
        -- printBSInfo("westCount", bs)
        if bs.stoneState == stState then
            westSideCount = westSideCount + 1
        end
    end
    
    -- print("southSideCount:"..southSideCount)
    -- print("eastSideCount:"..eastSideCount)
    -- print("northSideCount:"..northSideCount)
    -- print("westSideCount:"..westSideCount)
    local wt=WTMAG8
    local midWt = 0
    local southWeight = 0
    local eastWeight = 0
    local northWeight = 0
    local westWeight = 0
    local unicorn = 0 -- af only one side lacks presence we up its weight
    if southSideCount == 0 then
        unicorn = unicorn + 1
        southWeight = wt
    end
    if  eastSideCount == 0 then
        unicorn = unicorn + 1
        eastWeight = wt
    end
    if  northSideCount == 0 then
        unicorn = unicorn + 1
        northWeight = wt
    end
    if  westSideCount == 0 then
        unicorn = unicorn + 1
        westWeight = wt
    end
    
    if southSideCount == 1 then
        southWeight = WTMAG4
    end
    if  eastSideCount == 1 then
        eastWeight = WTMAG4
    end
    if  northSideCount == 1 then
        northWeight = WTMAG4
    end
    if  westSideCount == 1 then
        westWeight = WTMAG4
    end
    
    if southSideCount == 2 then
        southWeight = WTMAG2
    elseif  eastSideCount == 2 then
        eastWeight = WTMAG2
    elseif  northSideCount == 2 then
        northWeight = WTMAG2
    elseif  westSideCount == 2 then
        westWeight = WTMAG2
    end
    local mx = 32 -- wt multipier for unicorn
    self.unicornFlag = false
    local unicornSide = 0
    if unicorn == 1 then
        -- we have 1 and only one side with no stones, quad the weight
        -- print("we have a unicorn")
        self.unicornFlag = true
        if southSideCount == 0 then
            -- print("south unicorn")
            southWeight = southWeight * mx
            unicornSide = SOUTH_BOARD_SIDE
        elseif  eastSideCount == 0 then
            -- print("east unicorn")
            eastWeight = eastWeight * mx
            unicornSide = EAST_BOARD_SIDE
        elseif  northSideCount == 0 then
            -- print("north unicorn")
            northWeight = northWeight * mx
            unicornSide = NORTH_BOARD_SIDE
        elseif  westSideCount == 0 then
            -- print("west unicorn")
            westWeight = westWeight * mx
            unicornSide = WEST_BOARD_SIDE
        end
    end
    
    
    local totalWeight = southWeight + westWeight + eastWeight + northWeight
    print("totalWeight: "..totalWeight)
    
    -- print("southWeight:"..southWeight)
    -- print("eastWeight:"..eastWeight)
    -- print("northWeight:"..northWeight)
    -- print("westWeight:"..westWeight)
    local wtdSqs = {}
    local midSqs ={}
    local avl = self.player.availableSquares
    -- print(# avl)
    local numAvail = #avl
    local midWtFactor= 32
    local southMidWt = southWeight*midWtFactor
    local eastMidWt = eastWeight*midWtFactor
    local northMidWt = northWeight*midWtFactor
    local westMidWt = westWeight*midWtFactor
    local wt = 0
    -- if currentTurnNumber > 20 or totalWeight == 0 then
    if totalWeight == 0 then
        -- no loc chk especially elimnates midsqs
        for i=1, numAvail do
            local bs = avl[i]
            table.insert(wtdSqs, bs)
        end
        return wtdSqs
    end
    for i=1, numAvail do
        -- print("for loop top")
        -- print("i="..i)
        local bs = avl[i]
        localBsInserted = false
        -- print(bs)
        side = self:getBoardSquareSide(bs)
        -- print("side")
        -- print(side)
        if self.unicornFlag then
            if side == SOUTH_BOARD_SIDE
            and unicornSide == SOUTH_BOARD_SIDE then
                goto southsidewtlabel
            elseif side == EAST_BOARD_SIDE
            and unicornSide == EAST_BOARD_SIDE then
                goto eastsidewtlabel
            elseif side == NORTH_BOARD_SIDE
            and unicornSide == NORTH_BOARD_SIDE then
                goto northsidewtlabel
                
            elseif side == WEST_BOARD_SIDE
            and unicornSide == WEST_BOARD_SIDE then
                goto westsidewtlabel
            end
        end
        ::southsidewtlabel::
        if side == SOUTH_BOARD_SIDE then
            if southWeight > 0 then
                bsInserted = true
                wt = southWeight
                if self:isMiddleSquare(bs) then
                    -- print("south midsq")                 
                    wt = southMidWt
                end
                -- print("adding to loc south wt: "..wt)
                for i=1, wt do
                    table.insert(wtdSqs, bs)
                end
            end   
        end
        if self.unicornFlag  then
                goto endmainwtlabel
        end
        ::eastsidewtlabel::
        if side == EAST_BOARD_SIDE then
            if eastWeight > 0 then
                bsInserted = true
                wt = eastWeight
                if self:isMiddleSquare(bs) then
                    -- print("east midsq")
                    wt = eastMidWt
                end
                -- print("adding to loc east wt: "..wt)
                for i=1, wt do
                    table.insert(wtdSqs, bs)
                end
            end
            
        end
        if self.unicornFlag then
            goto endmainwtlabel
        end
        ::northsidewtlabel::
        if side == NORTH_BOARD_SIDE then
            if northWeight > 0 then
                bsInserted = true
                wt = northWeight
                if self:isMiddleSquare(bs) then
                    -- print("north midsq")
                    wt = northMidWt
                end
                -- print("adding to loc north wt: "..wt)
                for i=1, wt do
                    table.insert(wtdSqs, bs)
                end
            end

        end
        if self.unicornFlag then
            goto endmainwtlabel
        end
        ::westsidewtlabel::
        if side == WEST_BOARD_SIDE then

            if westWeight > 0 then
                bsInserted = true
                wt = westWeight
                if self:isMiddleSquare(bs) then
                    -- print("west midsq")
                    wt = westMidWt
                end
                -- print("adding to loc west wt: "..wt)
                for i=1, wt do
                    table.insert(wtdSqs, bs)
                end           
            end
            if self.unicornFlag then
                goto endmainwtlabel
            end        
        end
        ::endmainwtlabel::
        if not bsInserted then
            table.insert(wtdSqs, bs)
        end
        
        --[[
        -- add weight for middle squares, for level 1:2 this is 5 middle sqs
        if self:isMiddleSquare(bs) then
            -- printBSInfo("found middle square", bs)  
            for i=1, WTMAG7 do
                table.insert(wtdSqs, bs)
            end
        else
            table.insert(wtdSqs, bs)
        end
          ]]
    end -- end for loop
    return wtdSqs
end

--[[
middle sqs are 5,3, or 1 sq
depending on level
level 1,2 == 5 sqs
level 3,4 == 3 sqs
level 5,6 = 1 sq
lvl 7 = 1 (extremely rare)
]]


function AIHelper:isMiddleSquare(bs) 
    -- print("isMiddleSquare")
    local lvl = bs.level
    local idx = bs.index
    local side = self:getBoardSquareSide(bs)
    lohiPair  = self:getLoHiPair(lvl, side)
    -- printBSInfo("isMiddle",bs)
    -- print("side: ", side)
    -- print("lohoPair.lo: "..lohiPair.lo.." lohiPair.hi: "..lohiPair.hi)
    
    local side = self:getBoardSquareSide(bs)
    local midLo = 0
    local midHi = 0
    if lvl == 1 then
        if theGameBoard.hasHandicap then
            midLo = lohiPair.lo + 2
            midHi = lohiPair.hi - 2
        elseif currentTurnNumber < 3 then
            midLo = lohiPair.lo + 4
            midHi = lohiPair.hi - 4
        elseif currentTurnNumber < 5 then
            midLo = lohiPair.lo + 3
            midHi = lohiPair.hi - 3
        else
            midLo = lohiPair.lo + 2
            midHi = lohiPair.hi - 2
        end
    elseif lvl == 2 then
        midLo = lohiPair.lo + 3
        if side == WEST_BOARD_SIDE then
            midHi = 38
        else
            midHi = lohiPair.hi - 3
        end
    elseif lvl == 3 then
        midLo = lohiPair.lo + 3
        if side == WEST_BOARD_SIDE then
            midHi = 30
        else
            midHi = lohiPair.hi - 3
        end
    elseif lvl == 4 then
        midLo = lohiPair.lo + 2
        if side == WEST_BOARD_SIDE then
            midHi = 23
        else
            midHi = lohiPair.hi - 2
        end
    -- levels 5 and 6 are just one square
    elseif lvl == 5 then
        midLo = lohiPair.lo + 2
        midHi = midLo
    -- levels 5 and 6 are just one square
    elseif lvl == 6 then
        midLo = lohiPair.lo + 1
        midHi = midLo
    else
        -- theoretically level 7- probably never oplayed on
        midLo = 1
        midHi = 1
    end
    -- print("midLo: "..midLo..". midHi: "..midHi..". idx: "..idx)
    -- printFmt("isMiddle - midLo: %d  midHi:%d", midLo, midHi)ii
    if idx >= midLo and idx <= midHi then
        -- printBSInfo("isMiddleSquare true", bs)eb 
        if self:isTooClose(bs) then
            return false
        end
          
        return true
    end

    return false
end


function AIHelper:isTooClose(bs)
    local stnSt = self.player.stoneState
    local rn = bs.rightNeighbor
    local rn1 = rn.rightNeighbor
    local rn2 = rn1.rightNeighbor
    -- local rn3 = rn2.rightNeighbor
    local ln = bs.leftNeighbor
    local ln1 = ln.leftNeighbor
    local ln2 = ln1.leftNeighbor
    local opStn  = self:getOpponentStone(stnSt)

    -- local ln3 = ln2.leftNeighbor
    -- dont want to add wt if other stns are too close
    if rn.stoneState == stnSt or rn1.stoneState == stnSt then
        return true
    elseif ln.stoneState == stnSt or ln1.stoneState == stnSt then
        return true
    end
    if rn1.stoneState == opStn then
        return true
    elseif ln1.stoneState == opStn then
        return true
    end
    return false
end
function AIHelper:getLoHiPair(level, side)
        -- if else case statements, nested
    -- print("lohi level:"..level.." side:")
    -- print(side) 
        local levelSideLoHiPair = LoHiPair(1,1)
        if level == 1 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level1South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level1East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level1North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level1West
            end
        elseif level == 2 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level2South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level2East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level2North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level2West
            end
        elseif level == 3 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level3South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level3East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level3North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level3West
            end
        elseif level == 4 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level4South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level4East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level4North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level4West
            end
        elseif level == 5 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level5South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level5East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level5North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level5West
            end
        elseif level == 6 then
            if side == SOUTH_BOARD_SIDE then
                levelSideLoHiPair = level6South
            elseif side == EAST_BOARD_SIDE then
                levelSideLoHiPair = level6East
            elseif side == NORTH_BOARD_SIDE then
                levelSideLoHiPair = level6North
            elseif side == WEST_BOARD_SIDE then
                levelSideLoHiPair = level6west
            end
        end
    -- levelTable  = theGameBoard.levelIndexTable[level]
        return levelSideLoHiPair
end
    


function AIHelper:getSideSquares(level, side)
        -- if else case statements, nested
        local levelSideLoHiPair = self:getLoHiPair(level, side)
        local loIdx = levelSideLoHiPair.lo
        local hiIdx = levelSideLoHiPair.hi
        sideSquares = {}
        
        local bs = nil
    -- print("loIdx:"..loIdx..". hiIdx.."..hiIdx)
        for i = loIdx, hiIdx do
            bs = getBoardSquareByLevelIndex(level, i)
            table.insert(sideSquares,bs)
        end
        if side == WEST_BOARD_SIDE then 
            bs = getBoardSquareByLevelIndex(level, 1)
           table.insert(sideSquares,bs)
        end
    return sideSquares
end
    
    

    
function AIHelper:getBoardSquareSide(bs)
    local level = bs.level
    local index = bs.index
    -- printBSInfo("get board side", bs)
    local southHiLoPair = self:getLoHiPair(level, SOUTH_BOARD_SIDE)
    local eastHiLoPair = self:getLoHiPair(level, EAST_BOARD_SIDE)
    local northHiLoPair = self:getLoHiPair(level, NORTH_BOARD_SIDE)
    local westHiLoPair = self:getLoHiPair(level, WEST_BOARD_SIDE)
    -- print("nhilo.lo: "..northHiLoPair.lo)
    -- print("index: "..index)
    -- logic skips corner sfquares west list does not incled the vcorner square
    if index >= southHiLoPair.lo and index <= southHiLoPair.hi then
        return SOUTH_BOARD_SIDE
    elseif index >= eastHiLoPair.lo and index <= eastHiLoPair.hi then
        return EAST_BOARD_SIDE
    elseif index >= northHiLoPair.lo and index <= northHiLoPair.hi then
        return NORTH_BOARD_SIDE
    elseif index >= westHiLoPair.lo and index <= westHiLoPair.hi then
        return WEST_BOARD_SIDE
    end
    return 1
    
end






function AIHelper:touched(touch)
    -- Codea does not automatically call this method
end

function AIHelper:initLevelSideLoHiPairs()
    -- sadly, i gave up finding an algorithm
    -- keeping these as globals, cause other classes could use 
    
    --[[
    level1South = LoHiPair(1, 13)
    level1East = LoHiPair(13, 25)
    level1North = LoHiPair(25, 37)
    level1West = LoHiPair(37, 48) -- circles around may need to alter for forloops #1 is part of 2 loops
    
      ]]
    -- skip corners on level 1
    level1South = LoHiPair(2, 12)
    level1East = LoHiPair(14, 24)
    level1North = LoHiPair(26, 36)
    level1West = LoHiPair(38, 48) 

    
    level2South = LoHiPair(1, 11)
    level2East = LoHiPair(11, 21)
    level2North = LoHiPair(21, 31)
    level2West = LoHiPair(31, 40) -- circles around may need to alter for forloops
    
    level3South = LoHiPair(1, 9)
    level3East = LoHiPair(9, 17)
    level3North = LoHiPair(17, 25)
    level3West = LoHiPair(25, 32) -- circles around may need to alter for forloops

    level4South = LoHiPair(1, 7)
    level4East = LoHiPair(7, 13)
    level4North = LoHiPair(13, 19)
    level4West = LoHiPair(19, 24) --circles around may need to alter for forloops
    
    level5South = LoHiPair(1, 5)
    level5East = LoHiPair(5, 9)
    level5North = LoHiPair(9, 13)
    level5West = LoHiPair(13, 17) -- circles around may need to alter for forloops
    
    
    level6South = LoHiPair(1, 3)
    level6East = LoHiPair(3, 5)
    level6North = LoHiPair(5, 7)
    level6West = LoHiPair(7, 8) -- circles around may need to alter for forloops
    
    level7South = LoHiPair(1, 1)
    level77East = LoHiPair(1, 1)
    level7North = LoHiPair(1, 1)
    level7West = LoHiPair(1, 1) -- circles around may need to alter for forloops
    
    
end


--# LoadDeleteMessagePanel
LoadDeleteMessagePanel = class()

function LoadDeleteMessagePanel:init(name, parent)
    -- you can accept and set parameters here
    self.logname = name
    self.parent = parent  -- LoadLogDialog caller
    self.x = WIDTH/2
    self.y = HEIGHT/2
    self.action = nil
    self.fontType ="helvetica-bold"
    self.loadButton = Button("Load")
    self.deleteButton = Button("Delete")
    self.cancelButton = Button("Cancel")
    self.active = false
    self.loadButton.action = function ()  end
    self.deleteButton.action = function ()   end
    self.cancelButton.action = function ()  end
    self.loadButton.border = true
    self.deleteButton.border = true
    self.cancelButton.border = true
    self.minWidth = 80
    self.loadButton.minWidth = self.minWidth
    self.deleteButton.minWidth = self.minWidth
    self.cancelButton.minWidth = self.minWidth
    self.borderColor=slategrayColor
    
end

function LoadDeleteMessagePanel:draw()
    -- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        -- caller has to set active to true to engage functionality
        return
    end
    pushStyle()
    local x = self.x
    local y = self.y 
    font("HelveticaNeue-bold")
    fontSize(18)
    textWrapWidth(400)
    local msg = string.format("Load or delete log \"%s\"?", self.logname)
    local w, h = textSize(msg)

    
    w =420
    h = h + 30 + 50
    bw = w +15
    bh = h+15
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2 
    ry = y-h/2
    y = y + 20
    
    fill(self.borderColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    
    
    fill(blackColor)
    text(msg,x, y )


        x = x - self.loadButton.size.x/2 -55
        y = y - h/2 +15
        self.loadButton.pos = vec2(x,y)
        x = x + 110
        self.deleteButton.pos = vec2(x,y)
          x = x + 110
         self.cancelButton.pos = vec2(x,y)
        self.loadButton:draw()
        self.deleteButton:draw()
        self.cancelButton:draw()
    popStyle()

end

function LoadDeleteMessagePanel:touched(touch)
    -- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        return
    end
    
    if self.loadButton:touched(touch) then
        self.active = false 
        self:loadLog(self.logname)
        return true
    elseif self.deleteButton:touched(touch) then
        self.parent:showDeleteConfirm(self.logname)
        return true
    elseif self.cancelButton:touched(touch) then
        self.active = false
        return false
    end
    -- fall thru no button touched
end



function LoadDeleteMessagePanel:loadLog(name)  
    local logName=name..".zlog"
    local logText = readLocalData(logName)
    local panel = self.parent.logPanel 
    panel.logText = logText
    local desc = string.format("Showing Saved Log \"%s\"", name)
    panel.logDescription = desc
    panel:initLogScroll()
    self.parent:close()
end












--# SaveGameDialog
SaveGameDialog = class()

function SaveGameDialog:init(gameName)
    -- you can accept and set parameters here
    print("SaveGameDialog:init()")
    print(gameName)
    self.gameName = gameName
    self.gameExt = ".zgame"
    self.gameNameTB = TextBox(0, 0, 250, self.gameName)
    self.gameNameTB.limit = 24
    self.message = "Enter name to save current game:"
    self.saveStr = "Save"
    self.cancelStr = "Cancel"
    self.x = WIDTH/2
    self.y = HEIGHT/3*2
    self.action = nil
    self.fontType ="helvetica-bold"
    self.saveButton = Button(self.saveStr)
    self.cancelButton = Button(self.cancelStr)
    self.active = false
    self.saveButton.action = function ()  end
    self.cancelButton.action = function ()  end
    self.saveButton.border = true
    self.cancelButton.border = true
    self.minWidth = 80
    self.saveButton.minWidth = self.minWidth
    self.cancelButton.minWidth = self.minWidth
    
end

function SaveGameDialog:draw()
-- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        -- caller has to set active to true to engage functionality
        return
    end
    pushStyle() 
    local x = self.x
    local y = self.y
    font("HelveticaNeue-bold")
    fontSize(18)
    textWrapWidth(500)
    local w, h = textSize(self.message)
    w = w + 240
    h = h + 20 + 100
    bw = w +15
    bh = h+15
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2
    ry = y-h/2
    y = y + 20
    
    fill(slategrayColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    
    fill(blackColor)
    y = y + 20
    text(self.message,x, y +10)
    y = y - 25
    x = x - 120
    text("Game Name:", x, y)
    x = x + 60
    y=y-10
    self.gameNameTB.x = x
    self.gameNameTB.y = y
    self.gameNameTB:draw()
    x = x - self.saveButton.size.x/2 + 45
    y = y - 45
    self.saveButton.pos = vec2(x,y)
    x = x + 110
    self.cancelButton.pos = vec2(x,y)
    self.saveButton:draw()
    self.cancelButton:draw()
    popStyle()
end

function SaveGameDialog:touched(touch)
-- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        return
    end
    
    if self.gameNameTB:touched(touch) then
        showKeyboard()
        self.gameNameTB.acceptInput = true
        textBoxAcceptingInput = self.gameNameTB
    else
        textBoxAcceptingInput = nil
        self.gameNameTB.acceptInput = false
        hideKeyboard()
    end
    if self.saveButton:touched(touch) then
        self.active = false
        if self.action then
            self.action()
        end
        self.gameName = self.gameNameTB.text
        return true
    elseif self.cancelButton:touched(touch) then
        self.active = false
        return false
    end
    -- fall thru no button touchedp
end





    

--# GameSerializer
GameSerializer = class()
--[[
methods to serialize and deserialize a game for saving and loading into and from local data
json.encode has issues with theMoveTable, mostly with boatdSquares
we may stil use json after scrubbing the data

  ]]
function GameSerializer:init()
    -- you can accept and set parameters here
    self.serializedTable = {}
    self.metaDataTable={}
end

function GameSerializer:createMetaDataTable()
    local mdt = {}
    -- some gloabals unlikely to change, but version info may be important
    mdt.class="GameMetadata"
    mdt.datesaved=os.date()
    mdt.gamename=gameName
    mdt.gameversion=gameVersion
    mdt.playermode=theSettings.playerMode
    mdt.blackplayername=theSettings.blackPlayerName
    mdt.whiteplayername=theSettings.whitePlayerName
    -- the following gloabals are tracked in move class
    mdt.currentturnnumber=currentTurnNumber
    mdt.movestate=moveState
    mdt.whitestonescaptured = theGameBoard.whiteStonesCaptured
    mdt.blackstonescaptured = theGameBoard.blackStonesCaptured
    -- this should be in the move table, but we want it handy
    mdt.boardStateTable =    currentMove.boardStateTable 
    
    return mdt
end

function GameSerializer:convertMoveToTable(mvObj)
    local mvt = {}
    mvt.class="Move"
    mvt.turnnumber = mvObj.turnNumber
    mvt.movetype = mvObj.moveType
    mvt.pass = mvObj.pass
    mvt.handicap = mvObj.handicap
    -- only need level nd index for ba
    if mvObj.bs == nil then
        mvt.bslevel = 0
        mvt.bsindex = 0
    else
        mvt.bslevel = mvObj.bs.level
        mvt.bsindex = mvObj.bs.index
    end
    mvt.whitestonescaptured = mvObj.whiteStonesCaptured
    -- print(mvObj.blackStonesCaptured)
    mvt.blackstonescaptured = mvObj.blackStonesCaptured
    local actTable =mvObj.activityTable
    local newActTable={}
    if actTable == nil then
        -- print("activity table nil")
    else
        local sz=#actTable
        if sz < 1 then
            -- print("activity table empty")
            goto zbreak1
        end
        for i=1, sz do
            actObj=actTable[i]
            t = self:convertMoveActivityToTable(actObj)
            table.insert(newActTable,t)
        end
        
    end
    ::zbreak1::
    mvt.activitytable=newActTable -- might be empty
    -- the boardStateTable is justba table of stone states, does not need converting
    mvt.boardstatetable = mvObj.boardStateTable
    return mvt
end

--[[
    self.moveState = moveState
    self.activityType = activityType
    self.boardSq = boardSq
    self.destBoardSq = destBoardSq
  ]]

function GameSerializer:convertMoveActivityToTable(actObj)
    print("convertMoveActivityToTable")
    mat={}
    mat.class="MoveActivity"
    mat.movestate=actObj.moveState
    mat.activitytype=actObj.activityType
    if actObj.boardSq==nil then
        mat.bslevel=0
        mat.bsindex=0
    else
        mat.bslevel=actObj.boardSq.level
        mat.bsindex=actObj.boardSq.index
    end
    if actObj.destBoardSq==nil then
        mat.destbslevel=0
        mat.destbsindex=0
    else
        mat.destbslevel=actObj.destBoardSq.level
        mat.destbsindex=actObj.destBoardSq.index
    end
    return mat
end

function GameSerializer:serializeCurrentGame()
    self.metaDataTable = self.createMetaDataTable()
    -- theMoveTable is a stack, but if we serialize/deser 1,,n 
    --  we should be ok
    -- basically we're flatening out tge move objs so the
    -- move and its subobjs can be recreated
    local serGameTable={}
    table.insert(serGameTable, self.metaDataTable)
    local sz = # theMoveTable
    for i=1, sz do
        local mvObj = theMoveTable[i]
        local aMoveTable = self:convertMoveToTable(mvObj)
        table.insert(serGameTable, aMoveTable)
    end
    jsonStr = json.encode(serGameTable, {indent=true})
    -- print(jsonStr)
    return jsonStr
  
end

function GameSerializer:convertMoveActivityAsTableToObject(mat)
    -- moveState, activityType, boardSq, destBoardSq
    local bs = getBoardSquareByLevelIndex(mat.bslevel, mat.bsindex)
    local destbs  = getBoardSquareByLevelIndex(mat.destbslevel, mat.destbsindex)
    local actObj = MoveActivity( mat.movestate,  mat.activitytype,bs,destbs)    
    return actObj
end


function GameSerializer:convertMoveAsTableToObject(mvt)
    local mvObj = Move(mvt.turnnumber, mvt.movetype)
    mvObj.pass = mvt.pass
    mvObj.handicap = mvt.handicap
    if mvt.bslevel == 0 or mvt.bsindex == 0 then
        mvObj.bs = nil
    else
        mvObj.bs = getBoardSquareByLevelIndex(mvt.bslevel, mvt.bsindex)
    end 
    mvObj.whiteStonesCaptured = mvt.whitestonescaptured
    -- print(mvObj.blackStonesCaptured)
    mvObj.blackStonesCaptured = mvt.blackstonescaptured
    print("mvtable->mvobj captured:")
    print(mvObj.whiteStonesCaptured)
    print(mvObj.blackStonesCaptured)
    local actTable =mvt.activitytable
    local newActTable={}
    if actTable == nil then
        -- print("activity table nil")
    else
        local sz=#actTable
        if sz < 1 then
            -- print("activity table empty")
            goto zbreak1
        end
        for i=1, sz do
            mat=actTable[i]
            t = self:convertMoveActivityAsTableToObject(mat)
            table.insert(newActTable,t)
        end    
    end
    ::zbreak1::
    mvObj.activityTable=newActTable -- might be empty
    print(mvObj.activutyTable)
    print(mvObj.activityTable)
    -- the boardStateTable is just a table of stone states, does not need converting
    mvObj.boardStateTable = mvt.boardstatetable
    print(mvObj.boardStateTable)
    return mvObj
end

function GameSerializer:deserialize(jsonStr)
    local metadataTable ={}
    local mvTable = {}
    
    local t = json.decode(jsonStr)
    metadataTable=t[1]
    -- mv table starts at idx 2
    for i=2, #t do
        local mvt=t[i]
        mvObj = self:convertMoveAsTableToObject(mvt)
        table.insert(mvTable, mvObj)
    end
    return metadataTable, mvTable
end




function GameSerializer:draw()
    -- Codea does not automatically call this method
end

function GameSerializer:touched(touch)
    -- Codea does not automatically call this method
end

--# LoadDeleteGameMessagePanel

LoadDeleteGameMessagePanel = class()

function LoadDeleteGameMessagePanel:init(name, parent)
    -- you can accept and set parameters here
    self.gameName = name
    self.parent = parent  -- LoadGameDialog caller
    self.x = WIDTH/2
    self.y = HEIGHT/2
    self.action = nil
    self.fontType ="helvetica-bold"
    self.loadButton = Button("Load")
    self.deleteButton = Button("Delete")
    self.cancelButton = Button("Cancel")
    self.active = false
    self.loadButton.action = function ()  end
    self.deleteButton.action = function ()   end
    self.cancelButton.action = function ()  end
    self.loadButton.border = true
    self.deleteButton.border = true
    self.cancelButton.border = true
    self.minWidth = 80
    self.loadButton.minWidth = self.minWidth
    self.deleteButton.minWidth = self.minWidth
    self.cancelButton.minWidth = self.minWidth    
    self.confirmLoseExistingMP = MessagePanel("Existing Game will be lost upon Restore. Is this OK?")
    self.confirmLoseExistingMP.action = function() self:loadGameConfirmed() end
    self.borderColor=slategrayColor
    
end

function LoadDeleteGameMessagePanel:draw()
    -- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        -- caller has to set active to true to engage functionality
        return
    end
    pushStyle()
    local x = self.x
    local y = self.y     font("HelveticaNeue-bold")
    fontSize(18)
    textWrapWidth(400)
    local msg = string.format("Load or delete game \"%s\"?", self.gameName)
    local w, h = textSize(msg)

    
    w =420
    h = h + 30 + 50
    bw = w +15
    bh = h+15
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2 
    ry = y-h/2
    y = y + 20
    
    fill(self.borderColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    
    
    fill(blackColor)
    text(msg,x, y )


        x = x - self.loadButton.size.x/2 -55
        y = y - h/2 +15
        self.loadButton.pos = vec2(x,y)
        x = x + 110
        self.deleteButton.pos = vec2(x,y)
          x = x + 110
         self.cancelButton.pos = vec2(x,y)
        self.loadButton:draw()
        self.deleteButton:draw()
        self.cancelButton:draw()
    
    -- will draw if actove
        self.confirmLoseExistingMP:draw()
    popStyle()

end

function LoadDeleteGameMessagePanel:touched(touch)
    -- Codea does not automatically call this method
    -- print(self.active)
    if not self.active then
        return
    end
    
    if self.loadButton:touched(touch) then
        self.active = false 
        self:loadGame(self.gameName)
        return true
    elseif self.deleteButton:touched(touch) then
        self.parent:showDeleteConfirm(self.gameName)
        return true
    elseif self.cancelButton:touched(touch) then
        self.active = false
        return false
    end
    -- fall thru no button touched
end



function LoadDeleteGameMessagePanel:loadGame(name)  
    if gameState == GAMESTATE_INPROGRESS then
        self.confirmLoseExistingMP.active=true
    else
        self:loadAndDeserializeGame(name)  
    end
    
end

function LoadDeleteGameMessagePanel:loadGameConfirmed()  
            self:loadAndDeserializeGame(self.gameName)  
end

function LoadDeleteGameMessagePanel:loadAndDeserializeGame(name)  
    local gamename=name..".zgame"
    local jsonStr = readLocalData(gamename)     
    self.parent:restoreGame(name,jsonStr)
    self.parent:close()
end












--# RestoreGameDialog
RestoreGameDialog = class()

function RestoreGameDialog:init(panel)
    -- you can accept and set parameters here
    print("RestoreGameDialog:init()")
    self.x = WIDTH/2
    self.y = HEIGHT/2
    self.gameNameTable = {}
    self:initGameNameTable()
    self.menuPanel=panel

    self.reverseSort = false
    self.gameExt = ".zgame"
    
    self.pgupButton= ImageTextButton("Documents:pgup_icon", "Documents:pgup_icon",0,0,"pgup")
    self.pgupButton.action = function() self:pageUp()  end
    self.pgupButton.w= 32
    self.pgupButton.h= 32
    self.pgupButton.fontColor=blackColor
 
    self.upButton= ImageTextButton("Documents:up_icon", "Documents:up_icon",0,0,"up")
    self.upButton.action = function() self:moveUp()  end
    self.upButton.w= 36
    self.upButton.h= 36
    self.upButton.fontColor=blackColor
    
    self.downButton= ImageTextButton("Documents:down_icon", "Documents:down_icon",0,0,"down")
    self.downButton.action = function() self:moveDown() end
    self.downButton.w= 36
    self.downButton.h= 36
    self.downButton.fontColor=blackColor
       
    self.pgdnButton= ImageTextButton("Documents:pgdn_icon", "Documents:pgdn_icon",0,0,"pgdn")
    self.pgdnButton.action = function() self:pageDown()  end
    self.pgdnButton.w= 32
    self.pgdnButton.h= 32
    self.pgdnButton.fontColor=blackColor
    
    self.sortButton= ImageTextButton("Documents:sort_icon", "Documents:sort_icon",0,0,"sort")
    self.sortButton.action = function() self:sortGameNameTable()  end
    self.sortButton.w= 32
    self.sortButton.h= 32
    self.sortButton.fontColor=blackColor
    
    self.closeButton = Button("Close")
    self.closeButton.minWidth = 100
    self.closeButton.border = true
    self.closeButton.action = function() self:close()  end
    self.selectedLog=""
    
    self.loadDeleteGameMessagePanel = LoadDeleteGameMessagePanel("your game name here", parent)

    
    -- if more than displayLimit logs are saved, we use up and down keys to navigate
    self.startNum=1
    self.displayLimit=18
    
    self.deleteGameMP= MessagePanel("Delete")
    self.deleteGameMP.action = function() end
    
    self.deletedGameMP = MessagePanel("Game deleted.")
    self.deletedGameMP.msgType = MESSAGE_PANEL_ALERT

    

end

function RestoreGameDialog:draw()
-- Codea does not automatically call this method
    if not self.active then
        -- caller has to set active to true to engage functionality
        return
    end
    pushStyle()
    local x = self.x
    local y = self.y
    
    -- textWrapWidth(500)
    -- local w, h = textSize(self.message)
    
    
    
    w =  WIDTH - 400
    h = HEIGHT - 110
    bw = w +15
    bh = h+15
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2
    ry = y-h/2
    y = y + 40
    
    fill(slategrayColor)
    roundRect(bx,by, bw,bh, 10)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 10)
    font("HelveticaNeue-bold")
    fontSize(24)
    fill(blackColor)
    y = y + 270
    text("Select game to load or delete:",x,y)
    y = y - 327
    
    w = w - 140
    h = h - 150
    bw = w +5
    bh = h + 5
    bx = x - bw/2
    by=y-bh/2
    rx = x- w/2
    ry = y-h/2 
    
    fill(blackColor)
    roundRect(bx,by, bw,bh, 5)
    fill(ivoryColor)
    roundRect(rx,ry, w,h, 5)
     fontSize(18)
        y = y + 280
    x = x - 120
    self.pgupButton.pos = vec2(x, y)
    self.pgupButton:draw()
    
    x = x +  60
    self.upButton.pos = vec2(x, y)
    self.upButton:draw()
    
    x = x +  60
    self.downButton.pos = vec2(x, y)
    self.downButton:draw()
    
    x = x +  60
    self.pgdnButton.pos = vec2(x, y)
    self.pgdnButton:draw()
    
    x = x +  60
    self.sortButton.pos = vec2(x, y)
    self.sortButton:draw()
    
    x=x-110
        y = y - 565
    fontSize(20)
    self.closeButton.pos = vec2(x, y)
    self.closeButton:draw()
            y = y + 565

    y = y - 42
    x=x-10
    fill(redColor)
    fontSize(22)
    local st = self.startNum
    local num = # self.gameNameTable
    if num > self.displayLimit then
        num = self.displayLimit
    end
    for i=st,num do
      local  b = self.gameNameTable[i]
        -- b.border=true
        b.pos = vec2(x,y)
        b:draw()
        y = y - 28
    end
    -- loaddelete only visible when it is active
    self.loadDeleteGameMessagePanel:draw()
    self.deleteGameMP:draw()
    -- self.logDeletedMP = MessagePanel("Log Deleted")
    self.deletedGameMP:draw()
    self.loadDeleteGameMessagePanel.confirmLoseExistingMP:draw()
end

function RestoreGameDialog:touched(touch)
-- Codea does not automatically call this method
    if self.deleteGameMP.active then
        -- alert("deleteMP touched")
        self.loadDeleteGameMessagePanel.active = false
        self.deleteGameMP:touched(touch)
        return 
    end
    if self.deletedGameMP.active then
        -- alert("deleteMP touched")i
        self.deletedGameMP:touched(touch)
        -- self.deleteLogMP.active = false   
        return 
    end
    if self.loadDeleteGameMessagePanel.confirmLoseExistingMP.active then
        self.loadDeleteGameMessagePanel.confirmLoseExistingMP:touched(touch)
        return
    end
    if self.loadDeleteGameMessagePanel.active then
        self.loadDeleteGameMessagePanel:touched(touch)
        return
    end
    -- self.deleteLogMP:touched(touch)     
    self.downButton:touched(touch)
    self.upButton:touched(touch)
    self.pgdnButton:touched(touch)
    self.pgupButton:touched(touch)
    self.sortButton:touched(touch)
    local num = # self.gameNameTable
    local st = self.startNum
    local num = # self.gameNameTable
    if num > self.displayLimit then
        num = self.displayLimit
    end
    for i=st,num do 
        local b = self.gameNameTable[i]    
        if b:touched(touch) then
            -- print(b.displayName)
            self:loadDeleteGame(b.displayName)
        end   
    end
    self.closeButton:touched(touch)
end









function RestoreGameDialog:moveDown() 
    local tblSz = # self.gameNameTable
    
    if tblSz < self.displayLimit/2 then
        -- for small lists don't bother
        return
    end
    -- displayLimit is idx of last name we sho
    self.displayLimit = self.displayLimit + 1
    local realLimit = self.displayLimit
    if realLimit > tblSz then
        realLimit = tblSz
    end
    if self.startNum > realLimit - 9 then
        -- we've gone down far enough
        return
    end
    -- ok, actually move it down
    self.startNum = self.startNum + 1
    
    
end

function RestoreGameDialog:moveUp() 
    if self.startNum <= 1 then
        return
    end
    local tblSz = # self.gamedeletedGameMPdeletedGameMPNameTable
    self.startNum = self.startNum - 1
        self.displayLimit = self.displayLimit -1

    --[[
    local realLimit = self.displayLimit
    if realLimit > tblSz then
        realLimit = tblSz
    end

    if self.displayLimit > realLimit - 9 then
        return
    end
      ]]

    
    
end

function RestoreGameDialog:pageUp() 
    -- print("pageUp()")
    local tblSz = # self.gameNameTable
    --[[
    if tblSz > self.displayLimit then
        -- pgup makes no sense
        return
    end
      ]]
    local pgSz =17
    self.startNum = self.startNum - pgSz
    -- print("startnum:"..self.startNum)
    if self.startNum <= 1 then 
        self.startNum = 1
        self.displayLimit = 18
        return
    end
    self.displayLimit = self.displayLimit - pgSz
    -- print("displayLimit:"..self.displayLimit)
end

function RestoreGameDialog:pageDown() 
    local tblSz = # self.gameNameTable
    if tblSz < self.displayLimit then
        -- pgdn makes no sense
        return
    end
    local pgSz = 17 -- one less than initial display limit
    
    self.startNum = self.startNum + pgSz
    self.displayLimit = self.displayLimit + pgSz
    --[[
    local realLimit = self.displayLimit
    
    if realLimit > tblSz then
        realLimit = tblSz
    end
    if self.startNum > realLimit then
        self.startNum = self.startNum - pgSz
        -- return
    end
      
    self.displayLimit = realLimit
    ]]
end


function RestoreGameDialog:close()
    self.active = false
end

function RestoreGameDialog:loadDeleteGame(name)
    -- alert("load/delete/cancel for log: "..name)
    -- make a new one every time
    self.loadDeleteGameMessagePanel = LoadDeleteGameMessagePanel(name, self)
    self.loadDeleteGameMessagePanel.active =true
    
end


function RestoreGameDialog:initGameNameTable()
    -- print("LoadLogDialog:initGameNameTable()")
    self.gameNameTable = {}
    local t  = listLocalData()
    local num = # t

    for i=1, num do
       local name = t[i]
        -- print("check out: "..name)
        local startIdx = #name - 6
        if string.find(name,".zgame",startIdx) == nil then
            -- no match
        else
            -- print("found game: "..name)
            local idx = #name-6
            local gamename = string.sub(name,1,idx)
            local aButton  = Button(gamename)
            aButton.action = function()  end

            aButton.minWidth = 450
            table.insert(self.gameNameTable, aButton)  
        end
    end
    -- table.sort (t, function (k1, k2) return k1.str < k2.str end )

    self:sortGameNameTable()
    
    -- num = #self.gameNameTable
    
end

function RestoreGameDialog:sortGameNameTable()
    if self.reverseSort then
        table.sort(self.gameNameTable, function(b1, b2) return b1.displayName > b2.displayName end )
        self.reverseSort = false
    else
        table.sort(self.gameNameTable, function(b1, b2) return b1.displayName < b2.displayName end )
        self.reverseSort = true
    end
    
end



function RestoreGameDialog:deleteGame(name)
    -- alert("deleteLog: "..name)
    local gameName=name..".zgame"
    saveLocalData(gameName, nil)
    msg = string.format("Game \"%s\" has been deleted", name)
    self.deletedGameMP.message = msg
    self.deletedGameMP.active = true
    self:initGameNameTable()
end

function  RestoreGameDialog:showDeleteConfirm (name)
    -- print("showDeleteConfirm:"..name)
    local str =string.format("Delete saved game \"%s\"? (This cannot be undone.)",name)
    self.deleteGameMP= MessagePanel(str)
    self.deleteGameMP.action = function() self:deleteGame(name) end
    self.deleteGameMP.active = true
end


--[[

  ]]

function RestoreGameDialog:restoreGame(name,jsonStr)
    print("restoreGame")
    pasteboard.copy(jsonStr)
    gameHasBeenRestored=true
    gameIsBeingRestored=true
    theMenuPanel:newBoard()
    local gmSerializer = GameSerializer()
    -- save current metadaa data need logic to restore
    
    local  mdt, mvTable = gmSerializer:deserialize(jsonStr)
    print("mvTable")
    print(mvTable)
    print(#mvTable)
    if mvTable and #mvTable > 0 then
        -- ok to continue
    else
        return false  
    end

    -- restore some  meta data to what it was
    -- at some pount we may need to check version for compatibilit
    theSettings.playerMode=  mdt.playermode
    theSettings.blackPlayerName=  mdt.blackplayername
    theSettings.whitePlayerName= mdt.whiteplayername
    -- need toget player info in sync
    -- theAIPlayer= AIPlayer()
    createAIPlayers()
    mainInit()
    gameIsBeingRestored=true
    theMenuPanel:newBoard()
    local currentGameMetada = gmSerializer:createMetaDataTable() -- this is a table
    metaJson =json.encode(currentGameMetada)
    saveLocalData("currentMetaData", metaJson)
    mainInfoMessage=string.format("%s (restored %s)",defaultInfoMessage,name)
    -- mainInfoMessage=defaultInfoMessage
    -- the following gloabals are tracked in move class
    currentTurnNumber=  mdt.currentturnnumber
    moveState= mdt.movestate
    theGameBoard.whiteStonesCaptured=mdt.whitestonescaptured
    theGameBoard.blackStonesCaptured=mdt.blackstonescaptured
    theMoveTable=mvTable 
    local mvObj = theMoveTable[1]
    updateBoardFromMoveObject(mvObj)
    checkCurrentPlayLevel()
    gameState=GAMESTATE_INPROGRESS   
    if triggerAIFirstMove then 
        gameHasBeenRestored=true
    end
    gameIsBeingRestored=false
    
    return true
end








--# DumpFunctions
-- refactor - holder for debugging dump functions
function printBSInfo(label,bs)
    local str = string.format("%s (level,index): %d,%d stoneState: %s", label, bs.level, bs.index, stoneStateText[bs.stoneState])
    print(str)
end

function dumpLocalDataKeys()
    local ldt = listLocalData()
    local sz = # ldt
    print("*********  BEGIN LOCAL DATA KEYS  ***********")
    for i=1, sz do
        
        print(ldt[i])
    end
    print("*********   END LOCAL DATA KEYS  ***********")
    
end


-- for debugging
function dumpBsTable() 
    print("BEGIN DUMP BS TABLE")
    for i=1, numSquares do
        bs = bsTable[i]
        if bs == nil then 
            print("square at position "..i.." is nil")
        else
            print("level, index at poition "..i..":"..bs.level..","..bs.index)
        end
    end
      print("END DUMP BS TABLE")
end
function dumpSpecifiedBsTable(aBsTable) 
    print("BEGIN DUMP SPECIFIED BS TABLE")
    for i=1, # aBsTable do
        bs = aBsTable[i]
        if bs == nil then 
            print("square at position "..i.." is nil")
        else
            print("level, index at poition "..i..": "..bs.level..","..bs.index)
        end
    end
      print("END DUMP SPECIFIED BS TABLE")
end

function dumpMoves()
    if next(theMoveTable) == nil then
   -- theMoveTable is empty
        print("dumpMoves:theMoveTable empty")
        return
    end
    local theLimit  = # theMoveTable.   --theMoveTableble is stack, so we iterate from end
    print ("BEGIN: dumpMoves")
    -- 
    local blackMv, whiteMv, whiteBs, blackBs = nil
    local str,hdrStr, blackStr, whiteStr = ""
    -- each stone has a line for its initial placemwnt
    -- then a line for each capture/advance activity
    blackStrTable = {}
    whiteStrTable = {}
    
    -- build up the string tables
    for i=theLimit,1,-1 do
        
        local mvObj=theMoveTable[i]
        local mvType=mvObj.moveType
        local bs = mvObj.bs
        
        if bs == nil then
            -- print("Move board square is nil")
            bs = BoardSquare(8,0,0,0)
        end
        -- str = string.format("Move: %d %s:%d,%d ", mvObj.turnNumber, moveInitials[mvType],bs.level, bs.index)
        -- ""print(str)
    
        if mvType == BLACKMOVE then
            -- print("setting up Black")
            blackStrTable = {}
            blackMv = mvObj
            blackBs = bs
            if blackMv.pass then
                blackStr = string.format("B:Pass                           ")
            else
                blackStr = string.format("B:%d,%d                  ",  blackBs.level, blackBs.index)
            end

            -- append to table
            table.insert(blackStrTable, blackStr)
            -- if last move was by black we want to check it
             if i==1 then
                whiteStr = ""
                whiteMv = nil
                whiteStrTable = {}
                goto activitylogic
            end
            goto zcontinue
        elseif mvType == WHITEMOVE then
            -- print("setting up white")
            whiteStrTable = {}
            whiteMv = mvObj
            whiteBs = bs
            -- if black has last move we use level 8 to signal yhat white did not play
            if whiteMv.pass then
                whiteStr = string.format("W:Pass    ")
            else
                whiteStr = string.format("W:%d,%d    ",  whiteBs.level, whiteBs.index)
            end
            -- append to table
             table.insert(whiteStrTable, whiteStr)
        else
            print("no action for mvType %d",mvType)
        end
        
        --[[
        if # blackStr == 0 then
            print("blackStr empty")
            goto zcontinue
        end
          ]]
        -- print("Move:"..mvObj.turnNumber.." "..moveInitials[mvType
        -- print(whiteStrTable)
        -- print(blackStrTable)
        ::activitylogic::
        if blackMv == nil then
            goto whiteactivity
        end
        actTable = blackMv.activityTable
        for i=1, # actTable do
            str=""
            mvAct = actTable[i]
            if mvAct.activityType == CAPTURE_ACTIVITY then
                bs = mvAct.boardSq
                str = string.format("     X:%d,%d                ",bs.level, bs.index)
                table.insert(blackStrTable, str)
            elseif mvAct.activityType == ADVANCE_ACTIVITY then
                fromBs = mvAct.boardSq
                toBs = mvAct.destBoardSq
                str = string.format("     A:%d,%d-->%d,%d      ",
                                        fromBs.level, fromBs.index, toBs.level, toBs.index)
                -- print("inserting ADVANCE into blackStrTable: "..str)
                table.insert(blackStrTable, str)
            end
        end
        
        
        ::whiteactivity::
        if whiteMv == nil then
            goto zprint
        end
        actTable = whiteMv.activityTable
        for i=1, # actTable do
            str="" 
            mvAct = actTable[i]
            if mvAct.activityType == CAPTURE_ACTIVITY then
                bs = mvAct.boardSq
                str = string.format("  X:%d,%d                ",bs.level, bs.index)
                table.insert(whiteStrTable, str)
            elseif mvAct.activityType == ADVANCE_ACTIVITY then
                fromBs = mvAct.boardSq
                toBs = mvAct.destBoardSq
                str = string.format("  A:%d,%d-->%d,%d      ",
                                        fromBs.level, fromBs.index, toBs.level, toBs.index)
                -- print("inserting ADVANCE into whiteStrTable: "..str)
                table.insert(whiteStrTable, str)
            end
        end
        
        
        
        ::zprint::
        blSize = # blackStrTable
        wtSize = # whiteStrTable
        maxSize = 0
    
        if blSize >= wtSize then
            maxSize = blSize
        else
            maxSize = wtSize
        end
        --[[
        print("string tbl dumps")
        for i = 1, blSize do
            print(blackStrTable[i])
        end
        for i = 1, wtSize do
            print(whiteStrTable[i])
        end
          ]]
        for i=1, maxSize do
            if i == 1 then
                hdrStr= string.format("%d.    ", blackMv.turnNumber)
                hdrStr=string.sub(hdrStr,1,5)
                if blSize >= 1 then
                    blackStr = blackStrTable[i]
                else
                    blackStr = "                                         "
                end
                if wtSize >= 1 then
                    whiteStr = whiteStrTable[i]
                else
                    whiteStr = ""
                end
                blackStr=string.sub(blackStr,1,15) 
                str = string.format("%s%s%s", hdrStr, blackStr, whiteStr)
            else  -- i > 1
                if blSize >= i then
                    blackStr = blackStrTable[i]
                else
                    blackStr = "                                         "
                end
                if wtSize >= i then
                    whiteStr = whiteStrTable[i]
                else
                    whiteStr = ""
                end
                blackStr=string.sub(blackStr,1,18) 
                str = string.format("%s%s", blackStr, whiteStr)
            end
            print(str)
        end
        
        -- print(str)
        ::zcontinue::
        -- blackStrTablee = {}
        -- whiteStrTable = {}
        blacksStr = ""
        whiteStr = ""
        
    end
        
end
  
-- this is precursor to display game log - essentially dump contents of undo table
function old_dumpMoves()
    if next(theMoveTable) == nil then
   -- theMoveTable is empty
        print("dumpMoves:theMoveTable empty")
        return
    end
    local theLimit  = # theMoveTable.   --theMoveTableble is stack, so we iterate from end
    print ("BEGIN: dumpMoves")
    -- 
    local blackMv, whiteMv, whiteBs, blackBs = nil
    local str,hdrStr, blackStr, whiteStr = ""
    
    for i=theLimit,1,-1 do
        
        local mvObj=theMoveTable[i]
        local mvType=mvObj.moveType
        local bs = mvObj.bs
        
        if bs == nil then
            print("Move board square is nil")
            bs = BoardSquare(8,0,0,0)
        end
        -- str = string.format("Move: %d %s:%d,%d ", mvObj.turnNumber, moveInitials[mvType],bs.level, bs.index)
        -- ""print(str)
        if mvType == BLACKMOVE then
            -- print("setting up Black")
            blackMv = mvObj
            blackBs = bs
            blackStr = string.format("B:%d,%d                  ",  blackBs.level, blackBs.index)
            -- if last move was by black we want to check it
             if i==1 then
                whiteStr = ""
                whiteMv = nil
                goto zprint
            end
        
            goto zcontinue
        elseif mvType == WHITEMOVE then
            -- print("setting up white")
            whiteMv = mvObj
            whiteBs = bs
            -- if black has last move we use level 8 to signal yhat white did not play
            whiteStr = string.format("W:%d,%d    ",  whiteBs.level, whiteBs.index)
    
        else
            print("no action for mvType %d",mvType)
        end
        if # blackStr == 0 then
            print("blackStr empty")
            goto zcontinue
        end
        ::zprint::
        -- print("Move:"..mvObj.turnNumber.." "..moveInitials[mvType
        hdrStr= string.format("%d.    ", blackMv.turnNumber)
        hdrStr=string.sub(hdrStr,1,5)
        blackStr=string.sub(blackStr,1,15)
        str = string.format("%s%s%s", hdrStr, blackStr, whiteStr)
        print(str)
        -- now print out captures under approprate column
        local blCaptures = blackMv.captureTable
        local wtCaptures = {}
        if whiteMv == nil then
            local wtCaptures = {}
        else
            wtCaptures = whiteMv.captureTable
        end
        -- print(blackMv)
        -- print(whiteMv)
        -- capstr=string.format("# of blCaptures: %d.  # wrcaptures: %d",#blCaptures, #wtCaptures)
        -- print(capstr)
        local maxCaptures = # blCaptures
        if maxCaptures < # wtCaptures then
            maxCaptures = # wtCaptures
        end
        local blCaptureStr = "                        "
        local wtCaptureStr = ""
        for i=1, maxCaptures do
            if i <= # blCaptures then
                local cbs = blCaptures[i]
                blCaptureStr = string.format("     X:%d,%d                ",cbs.level, cbs.index)
            end
            if i <= # wtCaptures then
                local cbs = wtCaptures[i]
                wtCaptureStr = string.format("     X:%d,%d",cbs.level, cbs.index)
            end
            blCaptureStr = string.sub(blCaptureStr,1,15)
            str = string.format("%s%s", blCaptureStr, wtCaptureStr)
            
            print(str)
            blCaptureStr = "                        "
            wtCaptureStr = ""
        end
        -- the advance table contains Advanced objects which contain a from and to boardsquar
        local blAdvances = blackMv.advanceTable
        local wtAdvances= {} 
        if whiteMv == nil then
            wtAdvances = {}
        else
            wtAdvances = whiteMv.advanceTable
        end
        -- advstr=string.format("# of blAdvances: %d.  # wtAdvances: %d",#blAdvances, #wtAdvances)
        -- print(advstr)
        local maxAdvances = # blAdvances
        if maxAdvances < # wtAdvances then
            maxAdvances = # wtAdvances
        end
        
        local blAdvanceStr = "                        "
        local wtAdvanceStr = ""
        for i=1, maxAdvances do
            if i <= # blAdvances then
                local adv = blAdvances[i]
                local fromBs = adv.from
                local toBs = adv.to
                blAdvanceStr = string.format("     A:%d,%d-->%d,%d      ",fromBs.level, fromBs.index, toBs.level, toBs.index)
                -- tmp
                -- print(blAdvanceStr)
            end
            if i <= # wtAdvances then
                local adv = wtAdvances[i]
                local fromBs = adv.from
                local toBs = adv.to
            wtAdvanceStr = string.format("  A:%d,%d-->%d,%d      ",fromBs.level, fromBs.index, toBs.level, toBs.index)
                -- print("wtAdvStr:"..wtAdvanceStr)
            end

        end
        blAdvanceStr = string.sub(blAdvanceStr,1,18)
        str = string.format("%s%s", blAdvanceStr, wtAdvanceStr)
        print(str)
        blacksStr = ""
        whiteStr = ""
        ::zcontinue::
    end -- end main for loop
    print ("END: dumpMoves")
    
end


--# Move
Move = class()

function Move:init(turnNumber, moveType)
-- each move i s a black or white     self.passMoveFloatingMP.draw() played on the board 
-- undo and redo works one move at a time
-- however for notational purpses, turn #n consists of black move and a white move n
    -- print("Move:init")

    self.turnNumber=turnNumber
    self.moveType = moveType -- whxxite or black stone 
    self.pass = false -- sometimes there's no play so you have to pass
    self.handicap = false  -- indicates that the 1st move by black is a handicap, the sqs are in activity table
    self.bs = nil-- initially played square

    -- MoveActiviies are captures and advances srored in order in which they occur
    self.activityTable = {}
-- these arebglobal values that change or potentially change with each move
     self.boardStateTable = {} -- boardState at end of move, currently used for undo redo
    self.whiteStonesCaptured = 0
    self.blackStonesCaptured = 0
end

-- switching to activity table, howeve we will support the old tbls for a while
-- insert at end
function Move:addCapture(bs)
    -- table.insert(self.captureTable, bs)
    local mvAct = MoveActivity(self.moveType, CAPTURE_ACTIVITY, bs)
    table.insert(self.activityTable, mvAct)
end

-- insert at end
function Move:addAdvance(fromBs, toBs)
    print("addAdvance")
    print(fromBs)
    print(toBs)
    -- adv = Advanced(fromBs, toBs)
    -- table.insert(self.advanceTable, adv)
    local mvAct = MoveActivity(self.moveType, ADVANCE_ACTIVITY, fromBs, toBs)
    table.insert(self.activityTable, mvAct)
end

function Move:addHandicap(bs)
    -- table.insert(self.captureTable, bs)
    local mvAct = MoveActivity(self.moveType, HANDICAP_ACTIVITY, bs)
    table.insert(self.activityTable, mvAct)
    self.handicap = true
end

function Move:draw()
    -- Codea does not automatically call this method
end

function Move:touched(touch)

    -- Codea does not automatically call this method
end

--# MoveActivity
--[[
A move activity is a capture or advance that occurs as a result of
a stone being placed on a game square.  For logging, game storage, etc, 
these activities must be stored in the order the occur,.  An advance could cause 
a stone capture for examle


  ]]

MoveActivity = class()

-- Globals
CAPTURE_ACTIVITY = 1
ADVANCE_ACTIVITY = 2
HANDICAP_ACTIVITY = 3

--[[
moveState = black or white
activity type is capture orbadvance
boatdsq = capture sq or from sq for advance
advance uses dest sq for the to sq

  ]]
function MoveActivity:init(moveState, activityType, boardSq, destBoardSq)
    -- you can accept and set parameters here
    self.moveState = moveState
    self.activityType = activityType
    self.boardSq = boardSq
    self.destBoardSq = destBoardSq
end

function MoveActivity:draw()
    -- Codea does not automatically call this method
end

function MoveActivity:touched(touch)
    -- Codea does not automatically call this method
end
